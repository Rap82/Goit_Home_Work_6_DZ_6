
# ===================  Home work 6 ========================

# =================== Робота з файлами ==========================

# ++++++++++++++++++  ФАЙЛОВІ ДЕСКРИПТОРИ  +++++++++++++++++++++++++


# У Python є абстракція над файлами — це покажчик на файл або файловий дескриптор. Нічого складного в цьому немає, 
# це навпаки спрощує роботу з багатьма системними ресурсами.

# Файловий дескриптор — це системний ресурс, доступ до якого надає операційна система. 
# Зазвичай файловий дескриптор можна відкрити (отримати/створити), закрити (повідомити систему, що робота з ним закінчена), 
# можна записати у нього щось і прочитати щось.

# ВІДКРИТТЯ ТА ЗАКРИТТЯ ФАЙЛІВ
# Таким чином, робота з файлами у Python починається з відкриття файла або отримання від системи доступу до файлу, 
# отримання того самого файлового дескриптора. Для цього є вбудована функція open, в яку треба обов'язково передати ім'я файлу, 
# який ми хочемо відкрити, і можна вказати як саме ми хочемо файл відкрити:

# fh = open('test_file.txt')
# В цьому прикладі fh — це файловий дескриптор, спеціальний об'єкт, через який ми можемо працювати з файлом.

# Після того, як робота з файлом завершена, треба повернути ресурс (файл) системі. 
# Для цього у файлового дескриптора треба викликати метод close:

# fh = open('test.txt')
# fh.close()
# Закривати файл треба обов'язково. Незакриті дескриптори можуть стати причиною великої кількості неочевидних проблем і складнощів. 
# Найпростіший випадок — це зіпсований файл і повністю загублена інформація, яка в ньому могла міститися.

# Крім того треба пам'ятати, що, оскільки файловий дескриптор — це ресурс, який надається операційною системою, 
# то будь-яке завершення роботи додатку (аварійне або штатне) не означає закриття усіх відкритих фалів і, знову ж таки, може привести до помилок.

# Якщо не вказати, як ми хочемо відкрити файл, то він відкривається тільки для читання і за допомогою fh можна буде тільки читати з файлу.
#  Якщо файлу з ім'ям test_file.txt в системі немає, то ви отримаєте виключення.

# Режими відкриття файлів в Python вибираються за допомогою другого аргументу функції open.

# Можливі режими для відкриття файлів:

# Режим	Значення
# 'r'	відкриття на читання (є значенням за замовчуванням).
# 'w'	відкриття на запис, вміст файлу видаляється, якщо файлу не існує, створюється новий.
# 'x'	відкриття на запис, якщо файлу не існує, інакше виключення.
# 'a'	відкриття на дозапис, інформація додається в кінець файлу.
# 'b'	відкриття у двійковому режимі.
# 't'	відкриття в текстовому режимі (є значенням за замовчуванням).
# '+'	відкриття на читання та запис
# ЧИТАННЯ ТА ЗАПИС У ФАЙЛ
# Для запису у файл використовується метод write у дескриптора fh. Цей метод повертає кількість записаних у файл символів.

# Парний до нього метод — це метод read, який дозволяє прочитати деяку кількість символів із файлу.

# fh = open('test.txt', 'w+')
# fh.write('hello!')
# fh.seek(0)

# first_two_symbols = fh.read(2)
# print(first_two_symbols)  # 'he'

# fh.close()
# В цьому прикладі ми відкрили файл для читання та запису. Записали у файл рядок 'hello!' та прочитали перші два символи із
#  файлу за допомогою методу read, вказавши у якості аргументу двійку.

# Щоб повернути курсор на початок файла, викликали метод seek та передали йому позицію, куди треба переміститися (0).

# Щоб прочитати весь вміст файлу за раз, можна викликати метод read без аргументів:

# fh = open('test.txt', 'w')
# fh.write('hello!')
# fh.close()

# fh = open('test.txt', 'r')
# all_file = fh.read()
# print(all_file)  # 'hello!'

# fh.close()
# Поки файловий дескриптор не закритий, ви можете читати із нього частинами, продовжуючи читання з того ж місця, на якому зупинилися:

# fh = open('test.txt', 'w')
# fh.write('hello!')
# fh.close()

# fh = open('test.txt', 'r')
# while True:
#     symbol = fh.read(1)
#     if len(symbol) == 0:
#         break
#     print(symbol)

# fh.close()
# В цьому прикладі у циклі ми зчитували та виводили у консоль вміст файлу по одному символу за раз. В результаті ви отримаєте у консолі:

# h
# e
# l
# l
# o
# !
# Ще є зручний спосіб читати файл порядково, по одному рядку за раз, для цього можна скористатися методом readline:

# fh = open('test.txt', 'w')
# fh.write('first line\nsecond line\nthird line')
# fh.close()

# fh = open('test.txt', 'r')
# while True:
#     line = fh.readline()
#     if not line:
#         break
#     print(line)

# fh.close()
# В консолі буде вивід:

# first line

# second line

# third line
# Та аналогічний метод readlines, який читає весь файл повністю, але повертає список рядків, де елемент списку — це один рядок

# fh = open('test.txt', 'w')
# fh.write('first line\nsecond line\nthird line')
# fh.close()

# fh = open('test.txt', 'r')
# lines = fh.readlines()
# print(lines)

# fh.close()
# Вивід у консолі буде:

# ['first line\n', 'second line\n', 'third line']
# Зверніть увагу, що всі методи, які читають файли порядково, не опускають (видаляють) символ переносу рядка.


# ===================== Завдання 1 /Task 1 ========================

# ++++++++++++++++  Читання з файлу по рядку метод *fh.readlines() +++++++++++++++++++


# +++++++++++++++++++++ Умова ++++++++++++++++++++++++++++++++++

# Нехай ми маємо текстовий файл, який містить дані з місячною заробітною платою по кожному розробнику компанії.

# Приклад файлу:

# Alex Korp,3000
# Nikita Borisenko,2000
# Sitarama Raju,1000
# Як бачимо, структура файлу – це прізвище розробника та значення його заробітної плати, розділеної комою.

# Розробіть функцію total_salary(path) (параметр path - шлях до файлу), яка буде розбирати текстовий файл
#  і повертати загальну суму заробітної плати всіх розробників компанії.

# Вимоги до завдання:

# функція total_salary повертає значення типу float
# для читання файлу функція total_salary використовує лише метод readline
# ми поки що не використовуємо менеджер контексту with

# +++++++++++++++Тестові значення записанні в файл *Zarplata_Zavdania_1.txt +++++++++++++++++++++++

# Alex Korp,3000
# Nikita Borisenko,2000
# Sitarama Raju,1000

# ++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

# from pathlib import Path    # Підключаємо функцію *Path для пошуку шляху до  файлу для читання з бібліотеки *pathlib

# import re                   # підключаємо бібліотеку re ,Для виділення з тексту числових значень використаємо метод *re.sub (*str(патерн пошуку), *str (рядок на який замінемо патерн) , *str(рядок в якому відбуватиметься  пошук і заміна ))

# def total_salary ( path ) : # Функція (параметр path - шлях до файлу), яка буде розбирати текстовий файл і повертати загальну суму заробітної плати всіх розробників компанії.
    
#     #print (path)           # тестовий прінт для перевіки отриманого значення

#     try:                    # Блок ,  *try: 
#                                     #      код в середені 
                                    
#                                     # *finally: який би збій не був в середені коду виконується обовязково код в тілі *finally
                                          
#                                     #      код в тілі *finally

#         fh = open (path , "r")   #  *fh - отримає значення відкритого файлу для читаня на який вкаже зміна *path. де "r" - позанчає що файл відкритий для читання 
        

#         lines = fh.readlines() # В будован функція яка повертає список рядків з файлу .*lines - буде містити список з всіх рядків файлу переданого в зміну *fh
       
#         patern = "\D+"      # *patern - зміна яка містить патерн , для пошуку в рядку , "\D+" - патер який позначає будь який символ крім цифри.

#         replace = ""        # *replace - містить пустий символ. використаємо для видалення всіх символів з рядка файлу крім чисел. 

#         #print(lines)       # тестовий прінт для перевіки отриманого значення

#         zarplata_all = 0    # зміна *zarplata_all буде містити суму всіх зарплат з файлу.

#         for line in lines : # Цикл в якому зміна *line буде наберати значення елементу списку *lines

#             zarplata = re.sub (patern, replace , line ) # Вбудован функція *re.sub (patern, replace , i) - повертає в зміну *zarplata значення зміненого рядка в якому всі нечислові десяткові символи заміненні на пустий символ , тобто повертає тільки кортеж з цифрами з рядка. 
            
#             #print(zarplata)                   # тестовий прінт для перевіки отриманого значення

#             zarplata_all += float (zarplata)   # Сумуємо всі значення зміної *zarplata приведеної до типу *float
    
#         return  zarplata_all  # Повернення результату з функції

#     finally:        # який би збій не був в середені коду закриває відкритий файл в кінці.

#         fh.close()  # Вудована функція закритя файлу який був відкритий вище. *fh.close(), Де fh - зміна в яку передали вікритий файл , *.close() метод закриття файлу.




# path = Path( "Zarplata_Zavdania_1.txt" )  # *path Присвоюється шлях до файлу з іменем "Zarplata_Zavdania_1.txt" з поточної папки в якій знаходиться файл з кодом який виконуємо.
#                                           #  якщо файл для читання знаходиться в іншій папці ніж поточна , потрібно вказувати повний шлях до цього файлу.

# print ( f'Зарплата всіх = {total_salary(path)} $ ' ) # Виводимо на екран  Зарплата всіх = *підставляється значення повернуті функцією total_salary(path)
#                                                      # Зарплата всіх = 6000.0 $ - вивід для значень запропанованих в завдані.



# ======================================= Завдання 2 /Task 2 ========================

# ++++++++++++++++  Запис в файл метод fh.write() +++++++++++++++++++


# +++++++++++++++++++++++++++++++++++++++   Умова    +++++++++++++++++++++++++++++++++

# У компанії є кілька відділів. Список працівників для кожного відділу має такий вигляд:

# ['Robert Stivenson,28', 'Alex Denver,30']
# Це список рядків із прізвищем та віком співробітника, розділеними комами.

# Реалізуйте функцію запису даних про співробітників у файл, щоб інформація про кожного співробітника починалася з нового рядка.

# Функція запису в файл write_employees_to_file(employee_list, path), де:

# path – шлях до файлу.
# employee_list - список зі списками співробітників по кожному відділу, як у прикладі нижче:
# [['Robert Stivenson,28', 'Alex Denver,30'], ['Drake Mikelsson,19']]
# Вимоги:

# запишіть вміст employee_list у файл, використовуючи режим "w".
# ми поки що не використовуємо менеджер контексту with
# кожен співробітник повинен бути записаний з нового рядка — тобто для попереднього списку вміст файлу має бути наступним:
# Robert Stivenson,28
# Alex Denver,30
# Drake Mikelsson,19

# +++++++++++++++Тестові значення *employee_list +++++++++++++++++++++++

# employee_list = [ ["Robert Stivenson,28", "Alex Denver,30", "Drake Mikelsson,19"] ,["Ro Stiv,48", "Alx Dver,50", "Dke Mison,49"]]- список списків

# ++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

from pathlib import Path    # Підключаємо функцію *Path для пошуку шляху до  файлу для читання з бібліотеки *pathlib

def write_employees_to_file( employee_list, path) :  # функцію запису даних про співробітників у файл(згідно *вимог завдання), 
                                                     # щоб інформація про кожного співробітника починалася з нового рядка,
                                                     # *path – шлях до файлу.
                                                     # *employee_list - список зі списками співробітників по кожному відділу,
    # print (path)   # тестовий прінт для перевіки отриманого значення
   
    try:             # Блок *try: - finally: - використовуємо для роботи з файлом і його успішного закриття в кінці.

        fh = open (path , 'w') # Передаєм вміст файлу в файловий дескриптор для запису .де *path – шлях до файлу з яким працюємо , 'w'- відкритий для запису.
        
        for employee_idex in employee_list :   # Цикл для проходженню по спискам в списку *employee_list
            
            for employee in employee_idex:     # Цикл для проходженню по елементам  з списку *employee_idex
            
                new_employee = employee + '\n' # *new_employee(тип*str) присвоюємо поточне занчення елемента *employee (тип*str) і дописуємо в кінці '\n'-перенос на новий рядок.

                # print (new_employee)         # тестовий прінт для перевіки отриманого значення

                fh.write (new_employee )       # Записуємо новий елемент в Файл з опрацьованого списку , методом *fh.write (*str), де fh - імя переданого файлу, *str - значення типу рядок яке хочемо записати в файл.
       
      

    
        


    finally:        # який би збій не був в середені коду закриває відкритий файл в кінці.

        fh.close()  # Вудована функція закритя файлу який був відкритий вище. *fh.close(), Де fh - зміна в яку передали вікритий файл , *.close() метод закриття файлу.
                    # З закриттям файлу завершуємо роботу з ним зберігши всі зміни які відбулись в тілі коду.



path = Path ( "employee_list_Zavdania_2.txt" ) # *path Присвоюється шлях до файлу з іменем "employee_list_Zavdania_2.txt" з поточної папки в якій знаходиться файл з кодом який виконуємо.
                                               #  якщо файл для читання знаходиться в іншій папці ніж поточна , потрібно вказувати повний шлях до цього файлу.


employee_list = [ ["Robert Stivenson,28", "Alex Denver,30", "Drake Mikelsson,19"] ,["Ro Stiv,48", "Alx Dver,50", "Dke Mison,49"]] # Тестові значення *employee_list


write_employees_to_file(employee_list, path) # Виклки функції для запису в вайл ,згідно вимого завдання.