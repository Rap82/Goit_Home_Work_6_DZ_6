
# ===================  Home work 6 ========================

# =================== Робота з файлами ==========================

# ++++++++++++++++++  ФАЙЛОВІ ДЕСКРИПТОРИ  +++++++++++++++++++++++++


# У Python є абстракція над файлами — це покажчик на файл або файловий дескриптор. Нічого складного в цьому немає, 
# це навпаки спрощує роботу з багатьма системними ресурсами.

# Файловий дескриптор — це системний ресурс, доступ до якого надає операційна система. 
# Зазвичай файловий дескриптор можна відкрити (отримати/створити), закрити (повідомити систему, що робота з ним закінчена), 
# можна записати у нього щось і прочитати щось.

# ВІДКРИТТЯ ТА ЗАКРИТТЯ ФАЙЛІВ
# Таким чином, робота з файлами у Python починається з відкриття файла або отримання від системи доступу до файлу, 
# отримання того самого файлового дескриптора. Для цього є вбудована функція open, в яку треба обов'язково передати ім'я файлу, 
# який ми хочемо відкрити, і можна вказати як саме ми хочемо файл відкрити:

# fh = open('test_file.txt')
# В цьому прикладі fh — це файловий дескриптор, спеціальний об'єкт, через який ми можемо працювати з файлом.

# Після того, як робота з файлом завершена, треба повернути ресурс (файл) системі. 
# Для цього у файлового дескриптора треба викликати метод close:

# fh = open('test.txt')
# fh.close()
# Закривати файл треба обов'язково. Незакриті дескриптори можуть стати причиною великої кількості неочевидних проблем і складнощів. 
# Найпростіший випадок — це зіпсований файл і повністю загублена інформація, яка в ньому могла міститися.

# Крім того треба пам'ятати, що, оскільки файловий дескриптор — це ресурс, який надається операційною системою, 
# то будь-яке завершення роботи додатку (аварійне або штатне) не означає закриття усіх відкритих фалів і, знову ж таки, може привести до помилок.

# Якщо не вказати, як ми хочемо відкрити файл, то він відкривається тільки для читання і за допомогою fh можна буде тільки читати з файлу.
#  Якщо файлу з ім'ям test_file.txt в системі немає, то ви отримаєте виключення.

# Режими відкриття файлів в Python вибираються за допомогою другого аргументу функції open.

# Можливі режими для відкриття файлів:

# Режим	Значення
# 'r'	відкриття на читання (є значенням за замовчуванням).
# 'w'	відкриття на запис, вміст файлу видаляється, якщо файлу не існує, створюється новий.
# 'x'	відкриття на запис, якщо файлу не існує, інакше виключення.
# 'a'	відкриття на дозапис, інформація додається в кінець файлу.
# 'b'	відкриття у двійковому режимі.
# 't'	відкриття в текстовому режимі (є значенням за замовчуванням).
# '+'	відкриття на читання та запис
# ЧИТАННЯ ТА ЗАПИС У ФАЙЛ
# Для запису у файл використовується метод write у дескриптора fh. Цей метод повертає кількість записаних у файл символів.

# Парний до нього метод — це метод read, який дозволяє прочитати деяку кількість символів із файлу.

# fh = open('test.txt', 'w+')
# fh.write('hello!')
# fh.seek(0)

# first_two_symbols = fh.read(2)
# print(first_two_symbols)  # 'he'

# fh.close()
# В цьому прикладі ми відкрили файл для читання та запису. Записали у файл рядок 'hello!' та прочитали перші два символи із
#  файлу за допомогою методу read, вказавши у якості аргументу двійку.

# Щоб повернути курсор на початок файла, викликали метод seek та передали йому позицію, куди треба переміститися (0).

# Щоб прочитати весь вміст файлу за раз, можна викликати метод read без аргументів:

# fh = open('test.txt', 'w')
# fh.write('hello!')
# fh.close()

# fh = open('test.txt', 'r')
# all_file = fh.read()
# print(all_file)  # 'hello!'

# fh.close()
# Поки файловий дескриптор не закритий, ви можете читати із нього частинами, продовжуючи читання з того ж місця, на якому зупинилися:

# fh = open('test.txt', 'w')
# fh.write('hello!')
# fh.close()

# fh = open('test.txt', 'r')
# while True:
#     symbol = fh.read(1)
#     if len(symbol) == 0:
#         break
#     print(symbol)

# fh.close()
# В цьому прикладі у циклі ми зчитували та виводили у консоль вміст файлу по одному символу за раз. В результаті ви отримаєте у консолі:

# h
# e
# l
# l
# o
# !
# Ще є зручний спосіб читати файл порядково, по одному рядку за раз, для цього можна скористатися методом readline:

# fh = open('test.txt', 'w')
# fh.write('first line\nsecond line\nthird line')
# fh.close()

# fh = open('test.txt', 'r')
# while True:
#     line = fh.readline()
#     if not line:
#         break
#     print(line)

# fh.close()
# В консолі буде вивід:

# first line

# second line

# third line
# Та аналогічний метод readlines, який читає весь файл повністю, але повертає список рядків, де елемент списку — це один рядок

# fh = open('test.txt', 'w')
# fh.write('first line\nsecond line\nthird line')
# fh.close()

# fh = open('test.txt', 'r')
# lines = fh.readlines()
# print(lines)

# fh.close()
# Вивід у консолі буде:

# ['first line\n', 'second line\n', 'third line']
# Зверніть увагу, що всі методи, які читають файли порядково, не опускають (видаляють) символ переносу рядка.


# ===================== Завдання 1 /Task 1 ========================

# ++++++++++++++++  Читання з файлу по рядку метод *fh.readlines() +++++++++++++++++++


# +++++++++++++++++++++ Умова ++++++++++++++++++++++++++++++++++

# Нехай ми маємо текстовий файл, який містить дані з місячною заробітною платою по кожному розробнику компанії.

# Приклад файлу:

# Alex Korp,3000
# Nikita Borisenko,2000
# Sitarama Raju,1000
# Як бачимо, структура файлу – це прізвище розробника та значення його заробітної плати, розділеної комою.

# Розробіть функцію total_salary(path) (параметр path - шлях до файлу), яка буде розбирати текстовий файл
#  і повертати загальну суму заробітної плати всіх розробників компанії.

# Вимоги до завдання:

# функція total_salary повертає значення типу float
# для читання файлу функція total_salary використовує лише метод readline
# ми поки що не використовуємо менеджер контексту with

# +++++++++++++++Тестові значення записанні в файл *Zarplata_Zavdania_1.txt +++++++++++++++++++++++

# Alex Korp,3000
# Nikita Borisenko,2000
# Sitarama Raju,1000

# ++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

# from pathlib import Path    # Підключаємо функцію *Path для пошуку шляху до  файлу для читання з бібліотеки *pathlib

# import re                   # підключаємо бібліотеку re ,Для виділення з тексту числових значень використаємо метод *re.sub (*str(патерн пошуку), *str (рядок на який замінемо патерн) , *str(рядок в якому відбуватиметься  пошук і заміна ))

# def total_salary ( path ) : # Функція (параметр path - шлях до файлу), яка буде розбирати текстовий файл і повертати загальну суму заробітної плати всіх розробників компанії.
    
#     #print (path)           # тестовий прінт для перевіки отриманого значення

#     try:                    # Блок ,  *try: 
#                                     #      код в середені 
                                    
#                                     # *finally: який би збій не був в середені коду виконується обовязково код в тілі *finally
                                          
#                                     #      код в тілі *finally

#         fh = open (path , "r")   #  *fh - отримає значення відкритого файлу для читаня на який вкаже зміна *path. де "r" - позанчає що файл відкритий для читання 
        

#         lines = fh.readlines() # В будован функція яка повертає список рядків з файлу .*lines - буде містити список з всіх рядків файлу переданого в зміну *fh
       
#         patern = "\D+"      # *patern - зміна яка містить патерн , для пошуку в рядку , "\D+" - патер який позначає будь який символ крім цифри.

#         replace = ""        # *replace - містить пустий символ. використаємо для видалення всіх символів з рядка файлу крім чисел. 

#         #print(lines)       # тестовий прінт для перевіки отриманого значення

#         zarplata_all = 0    # зміна *zarplata_all буде містити суму всіх зарплат з файлу.

#         for line in lines : # Цикл в якому зміна *line буде наберати значення елементу списку *lines

#             zarplata = re.sub (patern, replace , line ) # Вбудован функція *re.sub (patern, replace , i) - повертає в зміну *zarplata значення зміненого рядка в якому всі нечислові десяткові символи заміненні на пустий символ , тобто повертає тільки кортеж з цифрами з рядка. 
            
#             #print(zarplata)                   # тестовий прінт для перевіки отриманого значення

#             zarplata_all += float (zarplata)   # Сумуємо всі значення зміної *zarplata приведеної до типу *float
    
#         return  zarplata_all  # Повернення результату з функції

#     finally:        # який би збій не був в середені коду закриває відкритий файл в кінці.

#         fh.close()  # Вудована функція закритя файлу який був відкритий вище. *fh.close(), Де fh - зміна в яку передали вікритий файл , *.close() метод закриття файлу.




# path = Path( "Zarplata_Zavdania_1.txt" )  # *path Присвоюється шлях до файлу з іменем "Zarplata_Zavdania_1.txt" з поточної папки в якій знаходиться файл з кодом який виконуємо.
#                                           #  якщо файл для читання знаходиться в іншій папці ніж поточна , потрібно вказувати повний шлях до цього файлу.

# print ( f'Зарплата всіх = {total_salary(path)} $ ' ) # Виводимо на екран  Зарплата всіх = *підставляється значення повернуті функцією total_salary(path)
#                                                      # Зарплата всіх = 6000.0 $ - вивід для значень запропанованих в завдані.



# ======================================= Завдання 2 /Task 2 ========================

# ++++++++++++++++  Запис в файл метод fh.write() +++++++++++++++++++


# +++++++++++++++++++++++++++++++++++++++   Умова    +++++++++++++++++++++++++++++++++

# У компанії є кілька відділів. Список працівників для кожного відділу має такий вигляд:

# ['Robert Stivenson,28', 'Alex Denver,30']
# Це список рядків із прізвищем та віком співробітника, розділеними комами.

# Реалізуйте функцію запису даних про співробітників у файл, щоб інформація про кожного співробітника починалася з нового рядка.

# Функція запису в файл write_employees_to_file(employee_list, path), де:

# path – шлях до файлу.
# employee_list - список зі списками співробітників по кожному відділу, як у прикладі нижче:
# [['Robert Stivenson,28', 'Alex Denver,30'], ['Drake Mikelsson,19']]
# Вимоги:

# запишіть вміст employee_list у файл, використовуючи режим "w".
# ми поки що не використовуємо менеджер контексту with
# кожен співробітник повинен бути записаний з нового рядка — тобто для попереднього списку вміст файлу має бути наступним:
# Robert Stivenson,28
# Alex Denver,30
# Drake Mikelsson,19

# +++++++++++++++Тестові значення *employee_list +++++++++++++++++++++++

# employee_list = [ ["Robert Stivenson,28", "Alex Denver,30", "Drake Mikelsson,19"] ,["Ro Stiv,48", "Alx Dver,50", "Dke Mison,49"]]- список списків

# ++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

# from pathlib import Path    # Підключаємо функцію *Path для пошуку шляху до  файлу для читання з бібліотеки *pathlib

# def write_employees_to_file( employee_list, path) :  # функцію запису даних про співробітників у файл(згідно *вимог завдання), 
#                                                      # щоб інформація про кожного співробітника починалася з нового рядка,
#                                                      # *path – шлях до файлу.
#                                                      # *employee_list - список зі списками співробітників по кожному відділу,
#     # print (path)   # тестовий прінт для перевіки отриманого значення
   
#     try:             # Блок *try: - finally: - використовуємо для роботи з файлом і його успішного закриття в кінці.

#         fh = open (path , 'w') # Передаєм вміст файлу в файловий дескриптор для запису .де *path – шлях до файлу з яким працюємо , 'w'- відкритий для запису.
        
#         for employee_idex in employee_list :   # Цикл для проходженню по спискам в списку *employee_list
            
#             for employee in employee_idex:     # Цикл для проходженню по елементам  з списку *employee_idex
            
#                 new_employee = employee + '\n' # *new_employee(тип*str) присвоюємо поточне занчення елемента *employee (тип*str) і дописуємо в кінці '\n'-перенос на новий рядок.

#                 # print (new_employee)         # тестовий прінт для перевіки отриманого значення

#                 fh.write (new_employee )       # Записуємо новий елемент в Файл з опрацьованого списку , методом *fh.write (*str), де fh - імя переданого файлу, *str - значення типу рядок яке хочемо записати в файл.
       
      

    
        


#     finally:        # який би збій не був в середені коду закриває відкритий файл в кінці.

#         fh.close()  # Вудована функція закритя файлу який був відкритий вище. *fh.close(), Де fh - зміна в яку передали вікритий файл , *.close() метод закриття файлу.
#                     # З закриттям файлу завершуємо роботу з ним зберігши всі зміни які відбулись в тілі коду.



# path = Path ( "employee_list_Zavdania_2.txt" ) # *path Присвоюється шлях до файлу з іменем "employee_list_Zavdania_2.txt" з поточної папки в якій знаходиться файл з кодом який виконуємо.
#                                                #  якщо файл для читання знаходиться в іншій папці ніж поточна , потрібно вказувати повний шлях до цього файлу.


# employee_list = [ ["Robert Stivenson,28", "Alex Denver,30", "Drake Mikelsson,19"] ,["Ro Stiv,48", "Alx Dver,50", "Dke Mison,49"]] # Тестові значення *employee_list


# write_employees_to_file(employee_list, path) # Виклик функції для запису в файл , згідно вимог  завдання.



# ======================================= Завдання 3 /Task 3 ========================

# ++++++++++++++++  ПРОЧИТАТИ ЗАПИСАНИЙ ФАЙЛ  метод fh.readlines() +++++++++++++++++++


# +++++++++++++++++++++++++++++++++++++++   Умова    +++++++++++++++++++++++++++++++++

# У попередній задачі ми записали співробітників у файл у такому вигляді:

# Robert Stivenson,28
# Alex Denver,30
# Drake Mikelsson,19
# Виконаємо тепер зворотнє завдання і створимо функцію read_employees_from_file(path), 
# яка читатиме дані з файлу та повертатиме список співробітників у вигляді:

# ['Robert Stivenson,28', 'Alex Denver,30', 'Drake Mikelsson,19']
# Пам'ятайте про наявність символу кінця рядка \n під час читання даних із файлу. 
# Його необхідно прибирати при додаванні прочитаного рядка до списку.

# Вимоги:

# прочитайте вміст файлу за допомогою режиму "r".
# ми поки що не використовуємо менеджер контексту with
# поверніть із функції список співробітників із файлу

# +++++++++++++++Тестові значення беремо з попереднього завдання де записували в файл *employee_list_Zavdania_2.txt +++++++++++++++++++++++


# ++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

# from pathlib import Path    # Підключаємо функцію *Path для пошуку шляху до  файлу для читання з бібліотеки *pathlib

# import re                   # підключаємо бібліотеку re ,Для виділення з тексту числових значень використаємо метод *re.sub (*str(патерн пошуку), *str (рядок на який замінемо патерн) , *str(рядок в якому відбуватиметься  пошук і заміна ))

# def read_employees_from_file (path) : # Функція (параметр path - шлях до файлу), яка буде розбирати текстовий файл і повертати загальну суму заробітної плати всіх розробників компанії.
    
#     #print (path)           # тестовий прінт для перевіки отриманого значення

#     try:                    # Блок *try: - finally: - використовуємо для роботи з файлом і його успішного закриття в кінці.

#         fh = open (path , "r")   #  *fh - отримає значення відкритого файлу для читаня на який вкаже зміна *path. де "r" - позанчає що файл відкритий для читання 
        

#         lines = fh.readlines() # В будован функція яка повертає список рядків з файлу .*lines - буде містити список з всіх рядків файлу переданого в зміну *fh
       
#         patern = "\n"      # *patern - зміна яка містить патерн , для пошуку в рядку , "\n" - патерн який позначає перенос на новий рядок.

#         replace = ""        # *replace - містить пустий символ. використаємо для видалення/перезаису всіх символів "\n" з рядка  . 

#         #print(lines)       # тестовий прінт для перевіки отриманого значення

#         list_employees_from_file = [] # *list_employees_from_file - міститме список співробітників згідно умови 

#         for line in lines : # Цикл в якому зміна *line буде наберати значення елементу списку *lines

#             employee_from_file = re.sub (patern, replace , line ) # Вбудован функція *re.sub (patern, replace , i) - повертає в зміну *employee_from_file значення зміненого рядка в якому всі символи  "\n" , будуть видалені(замінені пустим символом )
#             #print(zarplata)                   # тестовий прінт для перевіки отриманого значення

#             list_employees_from_file.append(employee_from_file) # *list_employees_from_file добавляємо до списку поточне значення рядка *employee_from_file методом *.append() - *name_list.append(*значення яке добавлємо до списку)
    
#         return  list_employees_from_file  # Повернення результату з функції.Повертає список згідно вимог завдання

#     finally:        # який би збій не був в середені коду закриває відкритий файл в кінці.

#         fh.close()  # Вудована функція закритя файлу який був відкритий вище. *fh.close(), Де fh - зміна в яку передали вікритий файл , *.close() метод закриття файлу.


# path = Path ( "employee_list_Zavdania_2.txt" )   # *path Присвоюється шлях до файлу з іменем "employee_list_Zavdania_2.txt" з поточної папки в якій знаходиться файл з кодом який виконуємо.
# #                                                #  якщо файл для читання знаходиться в іншій папці ніж поточна , потрібно вказувати повний шлях до цього файлу.


# print( read_employees_from_file (path) )         # Виводимо на екран список . # В нашому випадку - ['Robert Stivenson,28', 'Alex Denver,30', 'Drake Mikelsson,19', 'Ro Stiv,48', 'Alx Dver,50', 'Dke Mison,49']


# ======================================= Завдання 4 /Task 4 ========================

# ++++++++++++++++  Режими відкритя файлів   +++++++++++++++++++

# Можливі режими для відкриття файлів:

# Режим	Позначення
# 'r'	відкриття на читання (є значенням за замовчуванням).
# 'w'	відкриття на запис, вміст файлу видаляється, якщо файлу не існує, створюється новий.
# 'x'	відкриття на запис, якщо файлу не існує, інакше виключення.
# 'a'	відкриття на дозапис, інформація додається в кінець файлу.
# 'b'	відкриття у двоїчному режимі.
# 't'	відкриття у текстовому режимі (є значенням за замовчуванням).
# '+'	відкриття на читання та запис

# +++++++++++++++++++++++++++++++++++++++   Умова    +++++++++++++++++++++++++++++++++

# Реалізуйте функцію add_employee_to_file(record, path), яка у файл (параметр path - шлях до файлу) 
# буде додавати співробітника (параметр record) у вигляді рядка "Drake Mikelsson,19".

# Вимоги:

# параметр record - співробітник у вигляді рядка виду "Drake Mikelsson,19"
# кожен запис у файл має починатися з нового рядка.
# необхідно щоб стара інформація у файлі теж зберігалася, тому при роботі з файлом відкрийте файл у режимі 'a',
# додайте співробітника record у файл і закрийте його
# ми поки що не використовуємо менеджер контексту with

# ++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++



    
# from pathlib import Path    # Підключаємо функцію *Path для пошуку шляху до  файлу для читання з бібліотеки *pathlib

# def add_employee_to_file ( record, path ) : # Функцію add_employee_to_file(record, path), яка у файл (параметр path - шлях до файлу) 
#                                             # буде додавати співробітника (параметр record) у вигляді рядка "Drake Mikelsson,19".

#     print ( path )                            # тестовий прінт для перевіки отриманого значення
   
#     try: 
#         fh = open ( path , 'a')             # *fh - отримає значення відкритого файлу для дозапису на який вкаже зміна *path. де "a" - позанчає що файл відкритий для дозапису в кінці файлу.
        
#         new_employee = record + '\n'        # *new_employee(тип*str) присвоюємо поточне занчення елемента *record (тип*str) і дописуємо в кінці '\n'-перенос на новий рядок.
        
#         print ( new_employee )              # тестовий прінт для перевіки отриманого значення

#         fh.write ( new_employee )           # Дописуємо новий елемент в кінці файлу , методом *fh.write (*str), де fh - імя переданого файлу, *str - значення типу рядок яке хочемо записати в файл.
    

#     finally:        # який би збій не був в середені коду закриває відкритий файл в кінці.

#         fh.close()  # Вудована функція закритя файлу який був відкритий вище. *fh.close(), Де fh - зміна в яку передали вікритий файл , *.close() метод закриття файлу.
#                     # Пісял закритя файлу всі зміни виконані в тілі коду будуть атоматично збережені  в файл *employee_list_record_Zavdania_4.txt - файл з яким працюємо в цьому завдані.



# path = Path ( "employee_list_record_Zavdania_4.txt" )  # *path Присвоюється шлях до файлу з іменем "employee_list_record_Zavdania_4.txt" з поточної папки в якій знаходиться файл з кодом який виконуємо.

# record = "Robert Stivenson,28" # Приклад рядка для тесту . ## інші приклади для тесту  -"Robert Stivenson,28", "Alex Denver,30", "Drake Mikelsson,19","Ro Stiv,48", "Alx Dver,50", "Dke Mison,49"


# add_employee_to_file(record, path) #  Виклик функції для запису в файл , згідно вимог  завдання.


# ======================================= Завдання 5 /Task 5 ========================

# ++++++++++++++++  Менеджер контекстів *with ... as :   +++++++++++++++++++

# Для покращення читабельності коду при збереженні функціоналу можна скористатися менеджером контексту open. 
# Менеджер контексту — це синтаксична конструкція, яка покращує читабельність коду, але не вносить ніякого додаткового функціоналу.

# with open('text.txt', 'w+') as fh:
    
# Менеджер контексту складається з ключового слова with, 
# після якого викликається сам менеджер і, якщо щось треба повернути з менеджера, то це щось можна передати у змінну, 
# оголошену після ключового слова as. Далі ставиться двокрапка і блок коду, який буде виконаний всередині менеджера. 
# У прикладі з try ... finally — це код, який йде всередині блоку try. Коли код виконається, менеджер контексту виконає те, 
# що повинен зробити в будь-якому випадку, закрити файл наприклад (це те, що відбуваєтья в блоку finally).

# Менеджер контексту open синтаксично повністю повторює свого класичного тезка open, вони повністю ідентичні з точки зору використання.

# З точки зору роботи цей приклад робить у точності теж саме, що і попередній з блоком try ... finally. 
# Але замість п'яти рядків коду, ви можете написати два, і код виглядає більш читабельним.

# Такий спосіб роботи з файлами є рекомендованим у Python, оскільки гарантує, що програміст не забуде закрити файл у будь-якому разі.

# +++++++++++++++++++++++++++++++++++++++   Умова    +++++++++++++++++++++++++++++++++


# Розробіть функцію get_cats_info(path), яка повертатиме список словників із даними котів у вигляді:

# [
#     {"id": "60b90c1c13067a15887e1ae1", "name": "Tayson", "age": "3"},
#     {"id": "60b90c2413067a15887e1ae2", "name": "Vika", "age": "1"},
#     {"id": "60b90c2e13067a15887e1ae3", "name": "Barsik", "age": "2"},
#     {"id": "60b90c3b13067a15887e1ae4", "name": "Simon", "age": "12"},
#     {"id": "60b90c4613067a15887e1ae5", "name": "Tessi", "age": "5"},
# ]

# Параметри функції:

# path - шлях до файлу
# Вимоги:

# прочитайте вміст файлу за допомогою режиму "r".
# ми використовуємо менеджер контексту with
# поверніть із функції список котів із файлу у потрібному форматі

# +++++++++++++++Тестові значення до завдання записані в файл *cats_list_Zavdania_5.txt +++++++++++++++++++++++

# Ми маємо таку структуру файлу:

# 60b90c1c13067a15887e1ae1,Tayson,3
# 60b90c2413067a15887e1ae2,Vika,1
# 60b90c2e13067a15887e1ae3,Barsik,2
# 60b90c3b13067a15887e1ae4,Simon,12
# 60b90c4613067a15887e1ae5,Tessi,5

# Кожен запис складається з трьох частин і починається з нового рядка. 
# Наприклад, для першого запису початок 60b90c1c13067a15887e1ae1 — це первинний ключ бази даних MongoDB. 
# Він завжди містить 12 байтів або рівно 24 символи. Далі ми бачимо прізвисько кота Tayson та його вік 3. 
# Всі частини запису розділені символом кома ,



# ++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++


# from pathlib import Path    # Підключаємо функцію *Path для пошуку шляху до  файлу для читання з бібліотеки *pathlib

# import re                   # підключаємо бібліотеку re , Для просунотої роботи з рядками.

# def get_cats_info ( path ) : # Функцію *get_cats_info ( path ), яка отримає дані з  файлу (параметр path - шлях до файлу) 
#                                             # і поверне список словників із даними котів як описано в умові .
    
#     #print ( path )                             # тестовий прінт для перевіки отриманого значення
   
#     cats_info_list_all = []          # Список в який будемо записувати дані зчитані з файла , де кожен елемент списку  записаний у вигляді словника  , відповідно до  умови завдання
#     Key_for_dict = ["id", "name", "age"]  # Список який містить ключі для формування словника .
#     cat_info_dict_up = {}   # *cat_info_dict_up - словник в який будемо записувати дані зчитанні з рядка файла .

    
   
#     with open (path, 'r') as fh :     # Відкриття файлу для читання через Менеджер контексту *with open('text.txt', 'w+') as fh: #Більше про менеджер дивись на початку завдання

        
#         cats_info = fh.readlines()   # *cats_info - присвоється список утворений з рядків зчитаних методом *fh.readlines() , метод *fh.readlines() зчитує з файла порядково і повертає список рядків від початку до кінця файлу.
#         #print (cats_info)
#         patern = "\n"    # Патерн для пошуку відповідності в рядку з файла і подальшої його заміни.
#         replace = ""     # *replace -містить пустий символ , використовуєця для заміни патерна 
        
#         #print (cats_info)                   # тестовий прінт для перевіки отриманого значення

#         for cat_info in cats_info :  # Цикл в якому будемо проходити по кожному елементу з списку *cats_info і замінювати символ переносу на новий рядок *\n , на пустий символ "" .
#                                      # Також розбивати кожний елемент списку на кортежі по символу ","- коми.
#                                      # і формувати словник з даними , де ключем  буде елемент з списку *Key_for_dict  , а значення ключа з будемо брати з списку *cat_info_list.

#             cat_info =  re.sub (patern, replace , cat_info )  # *cat_info отримає змінений рядок без символу вказаному у *patern за допомогою в будованої функції re.sub (*str , *str , *str) 
#                                                               # *re.sub (patern, replace , cat_info ) , функція отримує рядок ,поточного значення з циклу *cat_info , виконує пошук в рядку по занченю *patern . 
#                                                               # міняє значення патерна на значення з *replace і повертає змінений рядок .
                                                                 
#             # print(cat_info)        # тестовий прінт для перевіки отриманого значення
            
#             cat_info_list = re.split (",", cat_info)   #  *cat_info_list отримає список з рядків сформованих вбудованою функцією re.split (*str, *str)
#                                                        #  *re.split (",", cat_info) , функція отримує рядок ,поточного значення з циклу *cat_info , і повертає список з його елементів розілених по символу ","
            
#             # print(cat_info_list)    # тестовий прінт для перевіки отриманого значення
            
#             cat_info_dict_up = dict( zip ( Key_for_dict, cat_info_list ) ) # *cat_info_dict_up отримає занчення типу словник сформований за допомогою вбудованих функції *dict ( *zip (*list , *list) ) і *zip (*list , *list)
#                                                                          #   *dict ( zip ( Key_for_dict, cat_info_list ) ) функція отримує список значень сфомованих функцією *zip ( Key_for_dict, cat_info_list ) і повертає словник утворений з них.
#                                                                          #   *zip(Key_for_dict,cat_info_list) функція отримує два значення , список *Key_for_dict і *cat_info_lis і повертає *обэкет де кожен елемент списку буде сформований в форматі
#                                                                          #   *[ 1_елемет_Key_for_dict : 1_елемет_cat_info_list , 2_елемет_Key_for_dict : 2_елемет_cat_info_list, *(і так далі ) ]
#              #print (cat_info_dict_up)
#             cats_info_list_all.append(cat_info_dict_up)  # Формуємо кінцевий список . Додаємо в циклі новий елемент списку ,дописуючи поточне значення отримане з *cat_info_dict_up
    
    
#     return cats_info_list_all  # Повертаємо з функції значення списку *cats_info_list_all



       
                     

   

# path = Path ( "cats_list_Zavdania_5.txt" )  # *path Присвоюється шлях до файлу з іменем "cats_list_Zavdania_5.txt" з поточної папки в якій знаходиться файл з кодом який виконуємо.




# print (get_cats_info ( path )) #  Виводимо значення повернуті з  функції *get_cats_info ( path )  


# ======================================= Завдання 6 /Task 6 ========================

# ++++++++++++++++  Менеджер контекстів *with ... as :   +++++++++++++++++++


# +++++++++++++++++++++++++++++++++++++++   Умова    +++++++++++++++++++++++++++++++++

# Нагадаємо, що у 4 модулі ми для кулінарного блогу писали функцію format_ingredients, яка приймала на вхід список з інгредієнтами рецепта.

# Ми продовжимо працювати в цьому напрямку та створимо функцію, яка шукатиме рецепт у файлі та повертатиме знайдений рецепт
# у вигляді словника певної форми.

# +++++++++++++++Тестові значення до завдання записані в файл *Recept_list_Zavdania_6.txt +++++++++++++++++++++++

# У вас є файл, який містить рецепти у вигляді:

#**********************************************************************************************************************
# 60b90c1c13067a15887e1ae1,Herbed Baked Salmon,4 lemons,1 large red onion,2 tablespoons chopped fresh basil
# 60b90c2413067a15887e1ae2,Lemon Pancakes,2 tablespoons baking powder,1 cup vanilla-flavored almond milk,1 lemon
# 60b90c2e13067a15887e1ae3,Chicken and Cold Noodles,6 ounces dry Chinese noodles,1 tablespoon sesame oil,3 tablespoons soy sauce
# 60b90c3b13067a15887e1ae4,Watermelon Cucumber Salad,1 large seedless watermelon,12 leaves fresh mint,1 cup crumbled feta cheese
# 60b90c4613067a15887e1ae5,State Fair Lemonade,6 lemons,1 cups white sugar,5 cups cold water

#*********************************************************************************************************************

# Кожен рецепт записаний з нового рядка (не забуваємо під час вирішення завдання про кінець рядка). 
# Кожен запис починається з первинного ключа бази даних MongoDB. Далі через кому, йде назва рецепта, 
# а потім через кому, йде перелік інгредієнтів рецепта.

# Вам необхідно реалізувати функцію, котра буде отримувати інформацію про рецепт у вигляді словника для кожної страви що шукається.
# Створіть функцію get_recipe(path, search_id), яка повертатиме словник для рецепта із зазначеним ідентифікатором MongoDB.

# Де параметри функції:

# path — шлях до файлу.
# search_id — первинний ключ MongoDB для пошуку рецепта
# Вимоги:

# Використовуйте менеджер контексту with для читання з файлу
# Якщо рецепта із зазначеним search_id у файлі немає, функція повинна повернути None
# Приклад: для файлу, вказаного вище, виклик функції у вигляді
# 
# get_recipe("./data/ingredients.csv", "60b90c3b13067a15887e1ae4")
# Повинен знайти у файлі рядок 60b90c3b13067a15887e1ae4,Watermelon Cucumber Salad,1 large seedless watermelon,
# 12 leaves fresh mint,1 cup crumbled feta cheese і повернути результат у вигляді словника такої структури:

# {
#     "id": "60b90c3b13067a15887e1ae4",
#     "name": "Watermelon Cucumber Salad",
#     "ingredients": [
#         "1 large seedless watermelon",
#         "12 leaves fresh mint",
#         "1 cup crumbled feta cheese",
#     ],
# }

from pathlib import Path
import re

def get_recipe( path, search_id ) :  # Функцію *get_recipe(path, search_id) , яка отримає дані з  файлу (параметр path - шлях до файлу) 
#                                             #  і  зміну *search_id в якій міститься ключ/id (тип *str)  . Потрібно перевірити чи таке *search_id є в файлі і якщо є,
                                              #  то повернути з функції цей  рядок з *search_id в записаний у вигляді словника.
                                              #  якщо такого значення ключа з *search_id - немає в файлі - повертаємо *None
                                              #  Для нашого тестового значення правильний результат {'id': '60b90c3b13067a15887e1ae4', 'name': 'Watermelon Cucumber Salad', 'ingredients': ['1 large seedless watermelon', '12 leaves fresh mint', '1 cup crumbled feta cheese']}
                                              #  Де перші дві пари з словника це ключ типу *str і значення типу *str а третя пара ключ типу *str а його значення типу *list . 
 
 
 new_recept_info_list = []  # Пустий список
 Key_for_dict = ["id", "name", "ingredients"] # Список який містить ключі нашого словника .
 recept_info_dict_up = {} # Пустий словник в який будемо записувати потрібне нам значення і повертати з функції.
 element_3 =[] # Пустий список в який будемо записувати значення 3 ключа з словника.

 with open (path , "r") as fh :  # # Відкриття файлу для читання через Менеджер контексту *with open('text.txt', 'w+') as fh: 
        
      recepts_info = fh.readlines()  # *recepts_info - присвоється список утворений з рядків зчитаних методом *fh.readlines() , метод *fh.readlines() зчитує з файла порядково і повертає список рядків від початку до кінця файлу.
      patern = "\n"                  # Патерн для пошуку відповідності в рядку з файла і подальшої його заміни.
      replace = ""                   # # *replace -містить пустий символ , використовуєця для заміни патерна 
      
      for recept_info in recepts_info : # цикл в якому будемо проходитись по кожному значенню з списку *recepts_info. 
                                        # Видаляти/замінти символ переносу рядка в кінці 
                                        # Розбивати кожен рядок на окремі елементи по занченюю символа ","
                                        # Перевіряти перше значення  на відповідність пошуку *search_id
                                        # Якщо співпадіння є то формувати відповідний словник і повертати з функції потрібне значення. 
                                        # Якщо співадіння немає з жлдним елементом з циклу то повертати занчення None
         recept_info =  re.sub (patern, replace , recept_info ) # *recept_info буде приймате значення поточного рядка з файлу  без символу *\n в кінці (Потрібно що позбутися символу переміщення на новий рядок в занченні яке будемо повертати)
        
         recept_info_list = re.split (",", recept_info)         # Функція яка отримує два параметри , перший по якому розбити рядок , другий який рядок розбивати . Повертає список типу *list  елементів типу *str .розбитих по вказаному символу.
                                                                # В нашому випадку перший параметер вказаний  символа коми  ",".Найде всі занчення до цього символа/символів і запише як елемент списку типу *list, і так до кінця рядка .Сам символ/символів,по якому розбивається ,буде відсутній в елементах списку.
                 
         count = 0    #  лічильик який будемо використовувати для роботи з елементами списку *recept_info_list
         
         if recept_info_list [0] == search_id :                 # Перевіряємо чи перший елементсписку *recept_info_list [0] який завжди буде містити поточне значення *id з рядка файлу який превіряємо ,
                                                                # якщо співпадіння є то це і є рядок який нам потрібно привести до потрібного формату і повернути з функції 
                                                                # Якщо співпадіння відсутнє відразу переходимо до  оператора *else
            
            for element in recept_info_list :        # вкаладений цикл в якому будемо формувати знайдене значення рядка до потрібного формату який описаний в умові завдання і в кінці повертати його.
                                                     # Проходимось по кожному елементу списку *recept_info_list
               
               if count < 2 :                        # умова в якій перші два елементи списку з нашого рядка записуємо в словник без змін.
                                                     # початкове значення count = 0 . 
                  
                  new_recept_info_list.append(element)  # Формуємо новий список добавляючи  поточноне значення *element задопомогою методу *.append()

                  count += 1                            # Збільшуємо значення лічильника на 1 . Для опрацювання наступного елементу списку .
               
               else :       #  Якщо умова *if count < 2 :  Невиконалась .Це і є наш 3 ключ знаяення якого потрібно записати у вигляді списка типу *list                
                  element_3.append(element) # Додаємо в список *element_3 поточні занчення *element до закінчення нашого в кладеного циклу  
                  
            #print(element_3)
            
            new_recept_info_list.append(element_3)  # Пілся завершення вбудованого циклу *for .Наш новий спосок буде вже містити перші два значення Добавляємо в нього третє яке буде записане в вигляді списку *element_3
                                                    # для нашого тестовго значення буде мати наступний вигляд . *['60b90c3b13067a15887e1ae4', 'Watermelon Cucumber Salad', ['1 large seedless watermelon', '12 leaves fresh mint', '1 cup crumbled feta cheese']]
            #print (new_recept_info_list)
             
            recept_info_dict_up = dict ( zip ( Key_for_dict, new_recept_info_list ) ) # Формуємо наш словник для повернення з функції.за допомогою вбудованих функції dict(*zip()) і 
                                                                                      # Функція *zip(*list,*list) - отримує два списка і формує пару ключ : значення . Де ключ це перший елемент з першого списку а значення перший елемент з списку другого. 
                                                                                      # Функція dict(*zip()) -повертає словник значень сформованих функцією *zip()
            
            
            break                 # перериваємо роботу циклу оператором *break . Оскільки нам потрібно повернути тільки одне значення подальша роботи функції має будути перервана.
         
         else:                                                 # Якщо умова *if recept_info_list [0] == search_id : - не виконалась присовюємо поточне значення *recept_info_dict_up = None
            recept_info_dict_up = None                         # Присвоюємо поточне значення *recept_info_dict_up = None Якщо умова  *if recept_info_list [0] == search_id : жодного разу не виконається до завершення циклу основного то
                                                               # повернем це значення з нашої функції. 
       
      
 return recept_info_dict_up                                    # Повертаємо кінцеве значення *recept_info_dict_up.



path = Path ("Recept_list_Zavdania6.txt")

search_id = "60b90c3b13067a15887e1ae4"

print ( get_recipe ( path, search_id ) )  #HПравильний результат для поточного тестового значення *search_id  #-  {'id': '60b90c3b13067a15887e1ae4', 'name': 'Watermelon Cucumber Salad', 'ingredients': ['1 large seedless watermelon', '12 leaves fresh mint', '1 cup crumbled feta cheese']}

