
# ===================  Home work 6 ========================

# =================== Робота з файлами ==========================

# ++++++++++++++++++  ФАЙЛОВІ ДЕСКРИПТОРИ  +++++++++++++++++++++++++


# У Python є абстракція над файлами — це покажчик на файл або файловий дескриптор. Нічого складного в цьому немає, 
# це навпаки спрощує роботу з багатьма системними ресурсами.

# Файловий дескриптор — це системний ресурс, доступ до якого надає операційна система. 
# Зазвичай файловий дескриптор можна відкрити (отримати/створити), закрити (повідомити систему, що робота з ним закінчена), 
# можна записати у нього щось і прочитати щось.

# ВІДКРИТТЯ ТА ЗАКРИТТЯ ФАЙЛІВ
# Таким чином, робота з файлами у Python починається з відкриття файла або отримання від системи доступу до файлу, 
# отримання того самого файлового дескриптора. Для цього є вбудована функція open, в яку треба обов'язково передати ім'я файлу, 
# який ми хочемо відкрити, і можна вказати як саме ми хочемо файл відкрити:

# fh = open('test_file.txt')
# В цьому прикладі fh — це файловий дескриптор, спеціальний об'єкт, через який ми можемо працювати з файлом.

# Після того, як робота з файлом завершена, треба повернути ресурс (файл) системі. 
# Для цього у файлового дескриптора треба викликати метод close:

# fh = open('test.txt')
# fh.close()
# Закривати файл треба обов'язково. Незакриті дескриптори можуть стати причиною великої кількості неочевидних проблем і складнощів. 
# Найпростіший випадок — це зіпсований файл і повністю загублена інформація, яка в ньому могла міститися.

# Крім того треба пам'ятати, що, оскільки файловий дескриптор — це ресурс, який надається операційною системою, 
# то будь-яке завершення роботи додатку (аварійне або штатне) не означає закриття усіх відкритих фалів і, знову ж таки, може привести до помилок.

# Якщо не вказати, як ми хочемо відкрити файл, то він відкривається тільки для читання і за допомогою fh можна буде тільки читати з файлу.
#  Якщо файлу з ім'ям test_file.txt в системі немає, то ви отримаєте виключення.

# Режими відкриття файлів в Python вибираються за допомогою другого аргументу функції open.

# Можливі режими для відкриття файлів:

# Режим	Значення
# 'r'	відкриття на читання (є значенням за замовчуванням).
# 'w'	відкриття на запис, вміст файлу видаляється, якщо файлу не існує, створюється новий.
# 'x'	відкриття на запис, якщо файлу не існує, інакше виключення.
# 'a'	відкриття на дозапис, інформація додається в кінець файлу.
# 'b'	відкриття у двійковому режимі.
# 't'	відкриття в текстовому режимі (є значенням за замовчуванням).
# '+'	відкриття на читання та запис
# ЧИТАННЯ ТА ЗАПИС У ФАЙЛ
# Для запису у файл використовується метод write у дескриптора fh. Цей метод повертає кількість записаних у файл символів.

# Парний до нього метод — це метод read, який дозволяє прочитати деяку кількість символів із файлу.

# fh = open('test.txt', 'w+')
# fh.write('hello!')
# fh.seek(0)

# first_two_symbols = fh.read(2)
# print(first_two_symbols)  # 'he'

# fh.close()
# В цьому прикладі ми відкрили файл для читання та запису. Записали у файл рядок 'hello!' та прочитали перші два символи із
#  файлу за допомогою методу read, вказавши у якості аргументу двійку.

# Щоб повернути курсор на початок файла, викликали метод seek та передали йому позицію, куди треба переміститися (0).

# Щоб прочитати весь вміст файлу за раз, можна викликати метод read без аргументів:

# fh = open('test.txt', 'w')
# fh.write('hello!')
# fh.close()

# fh = open('test.txt', 'r')
# all_file = fh.read()
# print(all_file)  # 'hello!'

# fh.close()
# Поки файловий дескриптор не закритий, ви можете читати із нього частинами, продовжуючи читання з того ж місця, на якому зупинилися:

# fh = open('test.txt', 'w')
# fh.write('hello!')
# fh.close()

# fh = open('test.txt', 'r')
# while True:
#     symbol = fh.read(1)
#     if len(symbol) == 0:
#         break
#     print(symbol)

# fh.close()
# В цьому прикладі у циклі ми зчитували та виводили у консоль вміст файлу по одному символу за раз. В результаті ви отримаєте у консолі:

# h
# e
# l
# l
# o
# !
# Ще є зручний спосіб читати файл порядково, по одному рядку за раз, для цього можна скористатися методом readline:

# fh = open('test.txt', 'w')
# fh.write('first line\nsecond line\nthird line')
# fh.close()

# fh = open('test.txt', 'r')
# while True:
#     line = fh.readline()
#     if not line:
#         break
#     print(line)

# fh.close()
# В консолі буде вивід:

# first line

# second line

# third line
# Та аналогічний метод readlines, який читає весь файл повністю, але повертає список рядків, де елемент списку — це один рядок

# fh = open('test.txt', 'w')
# fh.write('first line\nsecond line\nthird line')
# fh.close()

# fh = open('test.txt', 'r')
# lines = fh.readlines()
# print(lines)

# fh.close()
# Вивід у консолі буде:

# ['first line\n', 'second line\n', 'third line']
# Зверніть увагу, що всі методи, які читають файли порядково, не опускають (видаляють) символ переносу рядка.


# ===================== Завдання 1 /Task 1 ========================

# ++++++++++++++++  Читання з файлу по рядку метод *fh.readlines() +++++++++++++++++++


# +++++++++++++++++++++ Умова ++++++++++++++++++++++++++++++++++

# Нехай ми маємо текстовий файл, який містить дані з місячною заробітною платою по кожному розробнику компанії.

# Приклад файлу:

# Alex Korp,3000
# Nikita Borisenko,2000
# Sitarama Raju,1000
# Як бачимо, структура файлу – це прізвище розробника та значення його заробітної плати, розділеної комою.

# Розробіть функцію total_salary(path) (параметр path - шлях до файлу), яка буде розбирати текстовий файл
#  і повертати загальну суму заробітної плати всіх розробників компанії.

# Вимоги до завдання:

# функція total_salary повертає значення типу float
# для читання файлу функція total_salary використовує лише метод readline
# ми поки що не використовуємо менеджер контексту with

# +++++++++++++++Тестові значення записанні в файл *Zarplata_Zavdania_1.txt +++++++++++++++++++++++

# Alex Korp,3000
# Nikita Borisenko,2000
# Sitarama Raju,1000

# ++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

# from pathlib import Path    # Підключаємо функцію *Path для пошуку шляху до  файлу для читання з бібліотеки *pathlib

# import re                   # підключаємо бібліотеку re ,Для виділення з тексту числових значень використаємо метод *re.sub (*str(патерн пошуку), *str (рядок на який замінемо патерн) , *str(рядок в якому відбуватиметься  пошук і заміна ))

# def total_salary ( path ) : # Функція (параметр path - шлях до файлу), яка буде розбирати текстовий файл і повертати загальну суму заробітної плати всіх розробників компанії.
    
#     #print (path)           # тестовий прінт для перевіки отриманого значення

#     try:                    # Блок ,  *try: 
#                                     #      код в середені 
                                    
#                                     # *finally: який би збій не був в середені коду виконується обовязково код в тілі *finally
                                          
#                                     #      код в тілі *finally

#         fh = open (path , "r")   #  *fh - отримає значення відкритого файлу для читаня на який вкаже зміна *path. де "r" - позанчає що файл відкритий для читання 
        

#         lines = fh.readlines() # В будован функція яка повертає список рядків з файлу .*lines - буде містити список з всіх рядків файлу переданого в зміну *fh
       
#         patern = "\D+"      # *patern - зміна яка містить патерн , для пошуку в рядку , "\D+" - патер який позначає будь який символ крім цифри.

#         replace = ""        # *replace - містить пустий символ. використаємо для видалення всіх символів з рядка файлу крім чисел. 

#         #print(lines)       # тестовий прінт для перевіки отриманого значення

#         zarplata_all = 0    # зміна *zarplata_all буде містити суму всіх зарплат з файлу.

#         for line in lines : # Цикл в якому зміна *line буде наберати значення елементу списку *lines

#             zarplata = re.sub (patern, replace , line ) # Вбудован функція *re.sub (patern, replace , i) - повертає в зміну *zarplata значення зміненого рядка в якому всі нечислові десяткові символи заміненні на пустий символ , тобто повертає тільки кортеж з цифрами з рядка. 
            
#             #print(zarplata)                   # тестовий прінт для перевіки отриманого значення

#             zarplata_all += float (zarplata)   # Сумуємо всі значення зміної *zarplata приведеної до типу *float
    
#         return  zarplata_all  # Повернення результату з функції

#     finally:        # який би збій не був в середені коду закриває відкритий файл в кінці.

#         fh.close()  # Вудована функція закритя файлу який був відкритий вище. *fh.close(), Де fh - зміна в яку передали вікритий файл , *.close() метод закриття файлу.




# path = Path( "Zarplata_Zavdania_1.txt" )  # *path Присвоюється шлях до файлу з іменем "Zarplata_Zavdania_1.txt" з поточної папки в якій знаходиться файл з кодом який виконуємо.
#                                           #  якщо файл для читання знаходиться в іншій папці ніж поточна , потрібно вказувати повний шлях до цього файлу.

# print ( f'Зарплата всіх = {total_salary(path)} $ ' ) # Виводимо на екран  Зарплата всіх = *підставляється значення повернуті функцією total_salary(path)
#                                                      # Зарплата всіх = 6000.0 $ - вивід для значень запропанованих в завдані.



# ======================================= Завдання 2 /Task 2 ========================

# ++++++++++++++++  Запис в файл метод fh.write() +++++++++++++++++++


# +++++++++++++++++++++++++++++++++++++++   Умова    +++++++++++++++++++++++++++++++++

# У компанії є кілька відділів. Список працівників для кожного відділу має такий вигляд:

# ['Robert Stivenson,28', 'Alex Denver,30']
# Це список рядків із прізвищем та віком співробітника, розділеними комами.

# Реалізуйте функцію запису даних про співробітників у файл, щоб інформація про кожного співробітника починалася з нового рядка.

# Функція запису в файл write_employees_to_file(employee_list, path), де:

# path – шлях до файлу.
# employee_list - список зі списками співробітників по кожному відділу, як у прикладі нижче:
# [['Robert Stivenson,28', 'Alex Denver,30'], ['Drake Mikelsson,19']]
# Вимоги:

# запишіть вміст employee_list у файл, використовуючи режим "w".
# ми поки що не використовуємо менеджер контексту with
# кожен співробітник повинен бути записаний з нового рядка — тобто для попереднього списку вміст файлу має бути наступним:
# Robert Stivenson,28
# Alex Denver,30
# Drake Mikelsson,19

# +++++++++++++++Тестові значення *employee_list +++++++++++++++++++++++

# employee_list = [ ["Robert Stivenson,28", "Alex Denver,30", "Drake Mikelsson,19"] ,["Ro Stiv,48", "Alx Dver,50", "Dke Mison,49"]]- список списків

# ++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

# from pathlib import Path    # Підключаємо функцію *Path для пошуку шляху до  файлу для читання з бібліотеки *pathlib

# def write_employees_to_file( employee_list, path) :  # функцію запису даних про співробітників у файл(згідно *вимог завдання), 
#                                                      # щоб інформація про кожного співробітника починалася з нового рядка,
#                                                      # *path – шлях до файлу.
#                                                      # *employee_list - список зі списками співробітників по кожному відділу,
#     # print (path)   # тестовий прінт для перевіки отриманого значення
   
#     try:             # Блок *try: - finally: - використовуємо для роботи з файлом і його успішного закриття в кінці.

#         fh = open (path , 'w') # Передаєм вміст файлу в файловий дескриптор для запису .де *path – шлях до файлу з яким працюємо , 'w'- відкритий для запису.
        
#         for employee_idex in employee_list :   # Цикл для проходженню по спискам в списку *employee_list
            
#             for employee in employee_idex:     # Цикл для проходженню по елементам  з списку *employee_idex
            
#                 new_employee = employee + '\n' # *new_employee(тип*str) присвоюємо поточне занчення елемента *employee (тип*str) і дописуємо в кінці '\n'-перенос на новий рядок.

#                 # print (new_employee)         # тестовий прінт для перевіки отриманого значення

#                 fh.write (new_employee )       # Записуємо новий елемент в Файл з опрацьованого списку , методом *fh.write (*str), де fh - імя переданого файлу, *str - значення типу рядок яке хочемо записати в файл.
       
      

    
        


#     finally:        # який би збій не був в середені коду закриває відкритий файл в кінці.

#         fh.close()  # Вудована функція закритя файлу який був відкритий вище. *fh.close(), Де fh - зміна в яку передали вікритий файл , *.close() метод закриття файлу.
#                     # З закриттям файлу завершуємо роботу з ним зберігши всі зміни які відбулись в тілі коду.



# path = Path ( "employee_list_Zavdania_2.txt" ) # *path Присвоюється шлях до файлу з іменем "employee_list_Zavdania_2.txt" з поточної папки в якій знаходиться файл з кодом який виконуємо.
#                                                #  якщо файл для читання знаходиться в іншій папці ніж поточна , потрібно вказувати повний шлях до цього файлу.


# employee_list = [ ["Robert Stivenson,28", "Alex Denver,30", "Drake Mikelsson,19"] ,["Ro Stiv,48", "Alx Dver,50", "Dke Mison,49"]] # Тестові значення *employee_list


# write_employees_to_file(employee_list, path) # Виклик функції для запису в файл , згідно вимог  завдання.



# ======================================= Завдання 3 /Task 3 ========================

# ++++++++++++++++  ПРОЧИТАТИ ЗАПИСАНИЙ ФАЙЛ  метод fh.readlines() +++++++++++++++++++


# +++++++++++++++++++++++++++++++++++++++   Умова    +++++++++++++++++++++++++++++++++

# У попередній задачі ми записали співробітників у файл у такому вигляді:

# Robert Stivenson,28
# Alex Denver,30
# Drake Mikelsson,19
# Виконаємо тепер зворотнє завдання і створимо функцію read_employees_from_file(path), 
# яка читатиме дані з файлу та повертатиме список співробітників у вигляді:

# ['Robert Stivenson,28', 'Alex Denver,30', 'Drake Mikelsson,19']
# Пам'ятайте про наявність символу кінця рядка \n під час читання даних із файлу. 
# Його необхідно прибирати при додаванні прочитаного рядка до списку.

# Вимоги:

# прочитайте вміст файлу за допомогою режиму "r".
# ми поки що не використовуємо менеджер контексту with
# поверніть із функції список співробітників із файлу

# +++++++++++++++Тестові значення беремо з попереднього завдання де записували в файл *employee_list_Zavdania_2.txt +++++++++++++++++++++++


# ++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

# from pathlib import Path    # Підключаємо функцію *Path для пошуку шляху до  файлу для читання з бібліотеки *pathlib

# import re                   # підключаємо бібліотеку re ,Для виділення з тексту числових значень використаємо метод *re.sub (*str(патерн пошуку), *str (рядок на який замінемо патерн) , *str(рядок в якому відбуватиметься  пошук і заміна ))

# def read_employees_from_file (path) : # Функція (параметр path - шлях до файлу), яка буде розбирати текстовий файл і повертати загальну суму заробітної плати всіх розробників компанії.
    
#     #print (path)           # тестовий прінт для перевіки отриманого значення

#     try:                    # Блок *try: - finally: - використовуємо для роботи з файлом і його успішного закриття в кінці.

#         fh = open (path , "r")   #  *fh - отримає значення відкритого файлу для читаня на який вкаже зміна *path. де "r" - позанчає що файл відкритий для читання 
        

#         lines = fh.readlines() # В будован функція яка повертає список рядків з файлу .*lines - буде містити список з всіх рядків файлу переданого в зміну *fh
       
#         patern = "\n"      # *patern - зміна яка містить патерн , для пошуку в рядку , "\n" - патерн який позначає перенос на новий рядок.

#         replace = ""        # *replace - містить пустий символ. використаємо для видалення/перезаису всіх символів "\n" з рядка  . 

#         #print(lines)       # тестовий прінт для перевіки отриманого значення

#         list_employees_from_file = [] # *list_employees_from_file - міститме список співробітників згідно умови 

#         for line in lines : # Цикл в якому зміна *line буде наберати значення елементу списку *lines

#             employee_from_file = re.sub (patern, replace , line ) # Вбудован функція *re.sub (patern, replace , i) - повертає в зміну *employee_from_file значення зміненого рядка в якому всі символи  "\n" , будуть видалені(замінені пустим символом )
#             #print(zarplata)                   # тестовий прінт для перевіки отриманого значення

#             list_employees_from_file.append(employee_from_file) # *list_employees_from_file добавляємо до списку поточне значення рядка *employee_from_file методом *.append() - *name_list.append(*значення яке добавлємо до списку)
    
#         return  list_employees_from_file  # Повернення результату з функції.Повертає список згідно вимог завдання

#     finally:        # який би збій не був в середені коду закриває відкритий файл в кінці.

#         fh.close()  # Вудована функція закритя файлу який був відкритий вище. *fh.close(), Де fh - зміна в яку передали вікритий файл , *.close() метод закриття файлу.


# path = Path ( "employee_list_Zavdania_2.txt" )   # *path Присвоюється шлях до файлу з іменем "employee_list_Zavdania_2.txt" з поточної папки в якій знаходиться файл з кодом який виконуємо.
# #                                                #  якщо файл для читання знаходиться в іншій папці ніж поточна , потрібно вказувати повний шлях до цього файлу.


# print( read_employees_from_file (path) )         # Виводимо на екран список . # В нашому випадку - ['Robert Stivenson,28', 'Alex Denver,30', 'Drake Mikelsson,19', 'Ro Stiv,48', 'Alx Dver,50', 'Dke Mison,49']


# ======================================= Завдання 4 /Task 4 ========================

# ++++++++++++++++  Режими відкритя файлів   +++++++++++++++++++

# Можливі режими для відкриття файлів:

# Режим	Позначення
# 'r'	відкриття на читання (є значенням за замовчуванням).
# 'w'	відкриття на запис, вміст файлу видаляється, якщо файлу не існує, створюється новий.
# 'x'	відкриття на запис, якщо файлу не існує, інакше виключення.
# 'a'	відкриття на дозапис, інформація додається в кінець файлу.
# 'b'	відкриття у двоїчному режимі.
# 't'	відкриття у текстовому режимі (є значенням за замовчуванням).
# '+'	відкриття на читання та запис

# +++++++++++++++++++++++++++++++++++++++   Умова    +++++++++++++++++++++++++++++++++

# Реалізуйте функцію add_employee_to_file(record, path), яка у файл (параметр path - шлях до файлу) 
# буде додавати співробітника (параметр record) у вигляді рядка "Drake Mikelsson,19".

# Вимоги:

# параметр record - співробітник у вигляді рядка виду "Drake Mikelsson,19"
# кожен запис у файл має починатися з нового рядка.
# необхідно щоб стара інформація у файлі теж зберігалася, тому при роботі з файлом відкрийте файл у режимі 'a',
# додайте співробітника record у файл і закрийте його
# ми поки що не використовуємо менеджер контексту with

# ++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++



    
# from pathlib import Path    # Підключаємо функцію *Path для пошуку шляху до  файлу для читання з бібліотеки *pathlib

# def add_employee_to_file ( record, path ) : # Функцію add_employee_to_file(record, path), яка у файл (параметр path - шлях до файлу) 
#                                             # буде додавати співробітника (параметр record) у вигляді рядка "Drake Mikelsson,19".

#     print ( path )                            # тестовий прінт для перевіки отриманого значення
   
#     try: 
#         fh = open ( path , 'a')             # *fh - отримає значення відкритого файлу для дозапису на який вкаже зміна *path. де "a" - позанчає що файл відкритий для дозапису в кінці файлу.
        
#         new_employee = record + '\n'        # *new_employee(тип*str) присвоюємо поточне занчення елемента *record (тип*str) і дописуємо в кінці '\n'-перенос на новий рядок.
        
#         print ( new_employee )              # тестовий прінт для перевіки отриманого значення

#         fh.write ( new_employee )           # Дописуємо новий елемент в кінці файлу , методом *fh.write (*str), де fh - імя переданого файлу, *str - значення типу рядок яке хочемо записати в файл.
    

#     finally:        # який би збій не був в середені коду закриває відкритий файл в кінці.

#         fh.close()  # Вудована функція закритя файлу який був відкритий вище. *fh.close(), Де fh - зміна в яку передали вікритий файл , *.close() метод закриття файлу.
#                     # Пісял закритя файлу всі зміни виконані в тілі коду будуть атоматично збережені  в файл *employee_list_record_Zavdania_4.txt - файл з яким працюємо в цьому завдані.



# path = Path ( "employee_list_record_Zavdania_4.txt" )  # *path Присвоюється шлях до файлу з іменем "employee_list_record_Zavdania_4.txt" з поточної папки в якій знаходиться файл з кодом який виконуємо.

# record = "Robert Stivenson,28" # Приклад рядка для тесту . ## інші приклади для тесту  -"Robert Stivenson,28", "Alex Denver,30", "Drake Mikelsson,19","Ro Stiv,48", "Alx Dver,50", "Dke Mison,49"


# add_employee_to_file(record, path) #  Виклик функції для запису в файл , згідно вимог  завдання.


# ======================================= Завдання 5 /Task 5 ========================

# ++++++++++++++++  Менеджер контекстів *with ... as :   +++++++++++++++++++

# Для покращення читабельності коду при збереженні функціоналу можна скористатися менеджером контексту open. 
# Менеджер контексту — це синтаксична конструкція, яка покращує читабельність коду, але не вносить ніякого додаткового функціоналу.

# with open('text.txt', 'w+') as fh:
    
# Менеджер контексту складається з ключового слова with, 
# після якого викликається сам менеджер і, якщо щось треба повернути з менеджера, то це щось можна передати у змінну, 
# оголошену після ключового слова as. Далі ставиться двокрапка і блок коду, який буде виконаний всередині менеджера. 
# У прикладі з try ... finally — це код, який йде всередині блоку try. Коли код виконається, менеджер контексту виконає те, 
# що повинен зробити в будь-якому випадку, закрити файл наприклад (це те, що відбуваєтья в блоку finally).

# Менеджер контексту open синтаксично повністю повторює свого класичного тезка open, вони повністю ідентичні з точки зору використання.

# З точки зору роботи цей приклад робить у точності теж саме, що і попередній з блоком try ... finally. 
# Але замість п'яти рядків коду, ви можете написати два, і код виглядає більш читабельним.

# Такий спосіб роботи з файлами є рекомендованим у Python, оскільки гарантує, що програміст не забуде закрити файл у будь-якому разі.

# +++++++++++++++++++++++++++++++++++++++   Умова    +++++++++++++++++++++++++++++++++


# Розробіть функцію get_cats_info(path), яка повертатиме список словників із даними котів у вигляді:

# [
#     {"id": "60b90c1c13067a15887e1ae1", "name": "Tayson", "age": "3"},
#     {"id": "60b90c2413067a15887e1ae2", "name": "Vika", "age": "1"},
#     {"id": "60b90c2e13067a15887e1ae3", "name": "Barsik", "age": "2"},
#     {"id": "60b90c3b13067a15887e1ae4", "name": "Simon", "age": "12"},
#     {"id": "60b90c4613067a15887e1ae5", "name": "Tessi", "age": "5"},
# ]

# Параметри функції:

# path - шлях до файлу
# Вимоги:

# прочитайте вміст файлу за допомогою режиму "r".
# ми використовуємо менеджер контексту with
# поверніть із функції список котів із файлу у потрібному форматі

# +++++++++++++++Тестові значення до завдання записані в файл *cats_list_Zavdania_5.txt +++++++++++++++++++++++

# Ми маємо таку структуру файлу:

# 60b90c1c13067a15887e1ae1,Tayson,3
# 60b90c2413067a15887e1ae2,Vika,1
# 60b90c2e13067a15887e1ae3,Barsik,2
# 60b90c3b13067a15887e1ae4,Simon,12
# 60b90c4613067a15887e1ae5,Tessi,5

# Кожен запис складається з трьох частин і починається з нового рядка. 
# Наприклад, для першого запису початок 60b90c1c13067a15887e1ae1 — це первинний ключ бази даних MongoDB. 
# Він завжди містить 12 байтів або рівно 24 символи. Далі ми бачимо прізвисько кота Tayson та його вік 3. 
# Всі частини запису розділені символом кома ,



# ++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++


# from pathlib import Path    # Підключаємо функцію *Path для пошуку шляху до  файлу для читання з бібліотеки *pathlib

# import re                   # підключаємо бібліотеку re , Для просунотої роботи з рядками.

# def get_cats_info ( path ) : # Функцію *get_cats_info ( path ), яка отримає дані з  файлу (параметр path - шлях до файлу) 
#                                             # і поверне список словників із даними котів як описано в умові .
    
#     #print ( path )                             # тестовий прінт для перевіки отриманого значення
   
#     cats_info_list_all = []          # Список в який будемо записувати дані зчитані з файла , де кожен елемент списку  записаний у вигляді словника  , відповідно до  умови завдання
#     Key_for_dict = ["id", "name", "age"]  # Список який містить ключі для формування словника .
#     cat_info_dict_up = {}   # *cat_info_dict_up - словник в який будемо записувати дані зчитанні з рядка файла .

    
   
#     with open (path, 'r') as fh :     # Відкриття файлу для читання через Менеджер контексту *with open('text.txt', 'w+') as fh: #Більше про менеджер дивись на початку завдання

        
#         cats_info = fh.readlines()   # *cats_info - присвоється список утворений з рядків зчитаних методом *fh.readlines() , метод *fh.readlines() зчитує з файла порядково і повертає список рядків від початку до кінця файлу.
#         #print (cats_info)
#         patern = "\n"    # Патерн для пошуку відповідності в рядку з файла і подальшої його заміни.
#         replace = ""     # *replace -містить пустий символ , використовуєця для заміни патерна 
        
#         #print (cats_info)                   # тестовий прінт для перевіки отриманого значення

#         for cat_info in cats_info :  # Цикл в якому будемо проходити по кожному елементу з списку *cats_info і замінювати символ переносу на новий рядок *\n , на пустий символ "" .
#                                      # Також розбивати кожний елемент списку на кортежі по символу ","- коми.
#                                      # і формувати словник з даними , де ключем  буде елемент з списку *Key_for_dict  , а значення ключа з будемо брати з списку *cat_info_list.

#             cat_info =  re.sub (patern, replace , cat_info )  # *cat_info отримає змінений рядок без символу вказаному у *patern за допомогою в будованої функції re.sub (*str , *str , *str) 
#                                                               # *re.sub (patern, replace , cat_info ) , функція отримує рядок ,поточного значення з циклу *cat_info , виконує пошук в рядку по занченю *patern . 
#                                                               # міняє значення патерна на значення з *replace і повертає змінений рядок .
                                                                 
#             # print(cat_info)        # тестовий прінт для перевіки отриманого значення
            
#             cat_info_list = re.split (",", cat_info)   #  *cat_info_list отримає список з рядків сформованих вбудованою функцією re.split (*str, *str)
#                                                        #  *re.split (",", cat_info) , функція отримує рядок ,поточного значення з циклу *cat_info , і повертає список з його елементів розілених по символу ","
            
#             # print(cat_info_list)    # тестовий прінт для перевіки отриманого значення
            
#             cat_info_dict_up = dict( zip ( Key_for_dict, cat_info_list ) ) # *cat_info_dict_up отримає занчення типу словник сформований за допомогою вбудованих функції *dict ( *zip (*list , *list) ) і *zip (*list , *list)
#                                                                          #   *dict ( zip ( Key_for_dict, cat_info_list ) ) функція отримує список значень сфомованих функцією *zip ( Key_for_dict, cat_info_list ) і повертає словник утворений з них.
#                                                                          #   *zip(Key_for_dict,cat_info_list) функція отримує два значення , список *Key_for_dict і *cat_info_lis і повертає *обэкет де кожен елемент списку буде сформований в форматі
#                                                                          #   *[ 1_елемет_Key_for_dict : 1_елемет_cat_info_list , 2_елемет_Key_for_dict : 2_елемет_cat_info_list, *(і так далі ) ]
#              #print (cat_info_dict_up)
#             cats_info_list_all.append(cat_info_dict_up)  # Формуємо кінцевий список . Додаємо в циклі новий елемент списку ,дописуючи поточне значення отримане з *cat_info_dict_up
    
    
#     return cats_info_list_all  # Повертаємо з функції значення списку *cats_info_list_all



       
                     

   

# path = Path ( "cats_list_Zavdania_5.txt" )  # *path Присвоюється шлях до файлу з іменем "cats_list_Zavdania_5.txt" з поточної папки в якій знаходиться файл з кодом який виконуємо.




# print (get_cats_info ( path )) #  Виводимо значення повернуті з  функції *get_cats_info ( path )  


# ======================================= Завдання 6 /Task 6 ========================

# ++++++++++++++++  Менеджер контекстів *with ... as :   +++++++++++++++++++


# +++++++++++++++++++++++++++++++++++++++   Умова    +++++++++++++++++++++++++++++++++

# Нагадаємо, що у 4 модулі ми для кулінарного блогу писали функцію format_ingredients, яка приймала на вхід список з інгредієнтами рецепта.

# Ми продовжимо працювати в цьому напрямку та створимо функцію, яка шукатиме рецепт у файлі та повертатиме знайдений рецепт
# у вигляді словника певної форми.

# +++++++++++++++  Тестові значення до завдання записані в файл *Recept_list_Zavdania_6.txt +++++++++++++++++++++++

# У вас є файл, який містить рецепти у вигляді:

#**********************************************************************************************************************
# 60b90c1c13067a15887e1ae1,Herbed Baked Salmon,4 lemons,1 large red onion,2 tablespoons chopped fresh basil
# 60b90c2413067a15887e1ae2,Lemon Pancakes,2 tablespoons baking powder,1 cup vanilla-flavored almond milk,1 lemon
# 60b90c2e13067a15887e1ae3,Chicken and Cold Noodles,6 ounces dry Chinese noodles,1 tablespoon sesame oil,3 tablespoons soy sauce
# 60b90c3b13067a15887e1ae4,Watermelon Cucumber Salad,1 large seedless watermelon,12 leaves fresh mint,1 cup crumbled feta cheese
# 60b90c4613067a15887e1ae5,State Fair Lemonade,6 lemons,1 cups white sugar,5 cups cold water

#*********************************************************************************************************************

# Кожен рецепт записаний з нового рядка (не забуваємо під час вирішення завдання про кінець рядка). 
# Кожен запис починається з первинного ключа бази даних MongoDB. Далі через кому, йде назва рецепта, 
# а потім через кому, йде перелік інгредієнтів рецепта.

# Вам необхідно реалізувати функцію, котра буде отримувати інформацію про рецепт у вигляді словника для кожної страви що шукається.
# Створіть функцію get_recipe(path, search_id), яка повертатиме словник для рецепта із зазначеним ідентифікатором MongoDB.

# Де параметри функції:

# path — шлях до файлу.
# search_id — первинний ключ MongoDB для пошуку рецепта
# Вимоги:

# Використовуйте менеджер контексту with для читання з файлу
# Якщо рецепта із зазначеним search_id у файлі немає, функція повинна повернути None
# Приклад: для файлу, вказаного вище, виклик функції у вигляді
# 
# get_recipe("./data/ingredients.csv", "60b90c3b13067a15887e1ae4")
# Повинен знайти у файлі рядок 60b90c3b13067a15887e1ae4,Watermelon Cucumber Salad,1 large seedless watermelon,
# 12 leaves fresh mint,1 cup crumbled feta cheese і повернути результат у вигляді словника такої структури:

# {
#     "id": "60b90c3b13067a15887e1ae4",
#     "name": "Watermelon Cucumber Salad",
#     "ingredients": [
#         "1 large seedless watermelon",
#         "12 leaves fresh mint",
#         "1 cup crumbled feta cheese",
#     ],
# }


# ++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++


# from pathlib import Path
# import re

# def get_recipe( path, search_id ) :  # Функцію *get_recipe(path, search_id) , яка отримає дані з  файлу (параметр path - шлях до файлу) 
# #                                             #  і  зміну *search_id в якій міститься ключ/id (тип *str)  . Потрібно перевірити чи таке *search_id є в файлі і якщо є,
#                                               #  то повернути з функції цей  рядок з *search_id в записаний у вигляді словника.
#                                               #  якщо такого значення ключа з *search_id - немає в файлі - повертаємо *None
#                                               #  Для нашого тестового значення правильний результат {'id': '60b90c3b13067a15887e1ae4', 'name': 'Watermelon Cucumber Salad', 'ingredients': ['1 large seedless watermelon', '12 leaves fresh mint', '1 cup crumbled feta cheese']}
#                                               #  Де перші дві пари з словника це ключ типу *str і значення типу *str а третя пара ключ типу *str а його значення типу *list . 
 
 
#  new_recept_info_list = []  # Пустий список
#  Key_for_dict = ["id", "name", "ingredients"] # Список який містить ключі нашого словника .
#  recept_info_dict_up = {} # Пустий словник в який будемо записувати потрібне нам значення і повертати з функції.
#  element_3 =[] # Пустий список в який будемо записувати значення 3 ключа з словника.

#  with open (path , "r") as fh :  # # Відкриття файлу для читання через Менеджер контексту *with open('text.txt', 'w+') as fh: 
        
#       recepts_info = fh.readlines()  # *recepts_info - присвоється список утворений з рядків зчитаних методом *fh.readlines() , метод *fh.readlines() зчитує з файла порядково і повертає список рядків від початку до кінця файлу.
#       patern = "\n"                  # Патерн для пошуку відповідності в рядку з файла і подальшої його заміни.
#       replace = ""                   # # *replace -містить пустий символ , використовуєця для заміни патерна 
      
#       for recept_info in recepts_info : # цикл в якому будемо проходитись по кожному значенню з списку *recepts_info. 
#                                         # Видаляти/замінти символ переносу рядка в кінці 
#                                         # Розбивати кожен рядок на окремі елементи по занченюю символа ","
#                                         # Перевіряти перше значення  на відповідність пошуку *search_id
#                                         # Якщо співпадіння є то формувати відповідний словник і повертати з функції потрібне значення. 
#                                         # Якщо співадіння немає з жлдним елементом з циклу то повертати занчення None
#          recept_info =  re.sub (patern, replace , recept_info ) # *recept_info буде приймате значення поточного рядка з файлу  без символу *\n в кінці (Потрібно що позбутися символу переміщення на новий рядок в занченні яке будемо повертати)
        
#          recept_info_list = re.split (",", recept_info)         # Функція яка отримує два параметри , перший по якому розбити рядок , другий який рядок розбивати . Повертає список типу *list  елементів типу *str .розбитих по вказаному символу.
#                                                                 # В нашому випадку перший параметер вказаний  символа коми  ",".Найде всі занчення до цього символа/символів і запише як елемент списку типу *list, і так до кінця рядка .Сам символ/символів,по якому розбивається ,буде відсутній в елементах списку.
                 
#          count = 0    #  лічильик який будемо використовувати для роботи з елементами списку *recept_info_list
         
#          if recept_info_list [0] == search_id :                 # Перевіряємо чи перший елементсписку *recept_info_list [0] який завжди буде містити поточне значення *id з рядка файлу який превіряємо ,
#                                                                 # якщо співпадіння є то це і є рядок який нам потрібно привести до потрібного формату і повернути з функції 
#                                                                 # Якщо співпадіння відсутнє відразу переходимо до  оператора *else
            
#             for element in recept_info_list :        # вкаладений цикл в якому будемо формувати знайдене значення рядка до потрібного формату який описаний в умові завдання і в кінці повертати його.
#                                                      # Проходимось по кожному елементу списку *recept_info_list
               
#                if count < 2 :                        # умова в якій перші два елементи списку з нашого рядка записуємо в словник без змін.
#                                                      # початкове значення count = 0 . 
                  
#                   new_recept_info_list.append(element)  # Формуємо новий список добавляючи  поточноне значення *element задопомогою методу *.append()

#                   count += 1                            # Збільшуємо значення лічильника на 1 . Для опрацювання наступного елементу списку .
               
#                else :       #  Якщо умова *if count < 2 :  Невиконалась .Це і є наш 3 ключ знаяення якого потрібно записати у вигляді списка типу *list                
#                   element_3.append(element) # Додаємо в список *element_3 поточні занчення *element до закінчення нашого в кладеного циклу  
                  
#             #print(element_3)
            
#             new_recept_info_list.append(element_3)  # Пілся завершення вбудованого циклу *for .Наш новий спосок буде вже містити перші два значення Добавляємо в нього третє яке буде записане в вигляді списку *element_3
#                                                     # для нашого тестовго значення буде мати наступний вигляд . *['60b90c3b13067a15887e1ae4', 'Watermelon Cucumber Salad', ['1 large seedless watermelon', '12 leaves fresh mint', '1 cup crumbled feta cheese']]
#             #print (new_recept_info_list)
             
#             recept_info_dict_up = dict ( zip ( Key_for_dict, new_recept_info_list ) ) # Формуємо наш словник для повернення з функції.за допомогою вбудованих функції dict(*zip()) і 
#                                                                                       # Функція *zip(*list,*list) - отримує два списка і формує пару ключ : значення . Де ключ це перший елемент з першого списку а значення перший елемент з списку другого. 
#                                                                                       # Функція dict(*zip()) -повертає словник значень сформованих функцією *zip()
            
            
#             break                 # перериваємо роботу циклу оператором *break . Оскільки нам потрібно повернути тільки одне значення подальша роботи функції має будути перервана.
         
#          else:                                                 # Якщо умова *if recept_info_list [0] == search_id : - не виконалась присовюємо поточне значення *recept_info_dict_up = None
#             recept_info_dict_up = None                         # Присвоюємо поточне значення *recept_info_dict_up = None Якщо умова  *if recept_info_list [0] == search_id : жодного разу не виконається до завершення циклу основного то
#                                                                # повернем це значення з нашої функції. 
       
      
#  return recept_info_dict_up                                    # Повертаємо кінцеве значення *recept_info_dict_up.



# path = Path ("Recept_list_Zavdania6.txt")    # *path присвоється шлях до вказаного файлу

# search_id = "60b90c3b13067a15887e1ae4"       # тестове значення для пошуку.

# print ( get_recipe ( path, search_id ) )  # Правильний результат для поточного тестового значення *search_id  #-  {'id': '60b90c3b13067a15887e1ae4', 'name': 'Watermelon Cucumber Salad', 'ingredients': ['1 large seedless watermelon', '12 leaves fresh mint', '1 cup crumbled feta cheese']}




# ======================================= Завдання 7 /Task 7 ========================

# ++++++++++++++++  Перезапис з одного файлу в інший з виправленням даних   +++++++++++++++++++


# +++++++++++++++++++++++++++++++++++++++   Умова    +++++++++++++++++++++++++++++++++

# Розробіть функцію sanitize_file(source, output), що переписує у текстовий файл output вміст текстового файлу source, очищений від цифр.

# Вимоги:

# прочитайте вміст файлу source, використовуючи менеджер контексту with та режим "r".
# запишіть новий очищений від цифр вміст файлу output, використовуючи менеджер контексту with та режим "w"
# запис нового вмісту файлу output має бути одноразовий і використовувати метод write


# ++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

# from pathlib import Path
# import re

# def sanitize_file ( source, output ) :  # Функцію *sanitize_file(source, output), що переписує у текстовий файл output вміст текстового файлу source, очищений від цифр.

#     with open ( source , "r" ) as fh :          # Відкриваємо файл *source(мітить шлях до вказаного файлу ) Для читання за допомогою менеджера контексту with ... as


#         file_read_source = fh.readlines ()    # считуємо вміст файлу переданий порядково в *fh за допомогою методу *імя_файл_дескриптора.readlines () 
#                                               #  *file_read_source - присвоється список де елементами будуть рядки з файлу.
#         # print ( file_read_source )
#         patern = "[0-9]"                      # Патерн для пошуку відповідності в рядку з файла і подальшої його заміни.
#         replace = ""                          # *replace -містить пустий символ , використовуєця для заміни патерна
        
#         with open ( output , "w" ) as fhs :       # Відкриваємо файл *output(мітить шлях до вказаного файлу ) Для pfgbce за допомогою менеджера контексту with ... as
            
#             for line_file in file_read_source : # Цикл в якому будемо проходитись по елемаентам списку *file_read_source який міститься рядки з файлу source
#                                                 # і за допомогою фінкції re.sub() очищати рядок від цифр. Методом заміни всіх цифр пустим символом.
#                                                 # Очищений рядок записуємо відразу в наш файл *output 
                  
#                 fhs.write ( re.sub ( patern, replace , line_file ) ) # Функція re.sub ( patern, replace ,line_file ) Отримує поточний рядок *line_file 
#                                                                     # Перевіряє чи є в ньому значення *patern , якщо є то міняє його на значення * replace і
#                                                                     # повертає змінений рядок .
#                                                                     # Метод fhs.write - Поверне в Файловий дискриптор *fhs рядок записаний по символьно який поверне функція re.sub()
#                                                                     # В кінці циклу в  *fhs буде містити весь файл який потрібно буде записати в *output
#                                                                     # Після закриття файлу менеджером контексту with ... as вміст *fhs буде записано і збережено в файл *output  
                

# source = Path ("Source_Zavdania_7.txt")  # тестовий файл містить :

#                                         # 60b90c1c13067a15887e1ae1,Herbed Baked Salmon,4 lemons,1 large red onion,2 tablespoons chopped fresh basil
#                                         # 60b90c2413067a15887e1ae2,Lemon Pancakes,2 tablespoons baking powder,1 cup vanilla-flavored almond milk,1 lemon
#                                         # 60b90c2e13067a15887e1ae3,Chicken and Cold Noodles,6 ounces dry Chinese noodles,1 tablespoon sesame oil,3 tablespoons soy sauce
#                                         # 60b90c3b13067a15887e1ae4,Watermelon Cucumber Salad,1 large seedless watermelon,12 leaves fresh mint,1 cup crumbled feta cheese
#                                         # 60b90c4613067a15887e1ae5,State Fair Lemonade,6 lemons,1 cups white sugar,5 cups cold water

# output = Path ("Output_Zavdania_7.txt") # тестовий файл буде мітити після очищення і запису  :

#                                         # bccaeae,Herbed Baked Salmon, lemons, large red onion, tablespoons chopped fresh basil
#                                         # bcaeae,Lemon Pancakes, tablespoons baking powder, cup vanilla-flavored almond milk, lemon
#                                         # bceaeae,Chicken and Cold Noodles, ounces dry Chinese noodles, tablespoon sesame oil, tablespoons soy sauce
#                                         # bcbaeae,Watermelon Cucumber Salad, large seedless watermelon, leaves fresh mint, cup crumbled feta cheese
#                                         # bcaeae,State Fair Lemonade, lemons, cups white sugar, cups cold water


# sanitize_file ( source, output )     # Виклик функції *sanitize_file ( source, output )


# ======================================= Завдання 8 /Task 8 ========================

# ++++++++++++++++  СТРУКТУРУЄМО ЗАПИС У ФАЙЛ   +++++++++++++++++++


# +++++++++++++++++++++++++++++++++++++++   Умова    +++++++++++++++++++++++++++++++++

# Задано відомість абітурієнтів, які склали вступні іспити до університету. 
# Структура даних щодо абітурієнтів подана у вигляді наступного списку:

# [
#     {
#         "name": "Kovalchuk Oleksiy",
#         "specialty": 301,
#         "math": 175,
#         "lang": 180,
#         "eng": 155,
#     },
#     {
#         "name": "Ivanchuk Boryslav",
#         "specialty": 101,
#         "math": 135,
#         "lang": 150,
#         "eng": 165,
#     },
#     {
#         "name": "Karpenko Dmitro",
#         "specialty": 201,
#         "math": 155,
#         "lang": 175,
#         "eng": 185,
#     },
# ]
# У кожному словнику цього списку записано прізвище абітурієнта — ключ name, код спеціальності, на яку він поступив — ключ specialty, 
# та отримані ним бали з окремих дисциплін — ключі math (математика), lang ( українська мова) та eng (англійська мова)

# Розробіть функцію save_applicant_data(source, output), яка буде вказаний список із параметра source зберігати у файл із параметра output

# Структура файлу для зберігання повинна бути наступною. У кожному новому рядку файлу повинні бути записані через кому без прогалин
# прізвище абітурієнта, код спеціальності, на яку він поступив, та отримані ним бали за окремими дисциплінами.

# Kovalchuk Oleksiy,301,175,180,155
# Ivanchuk Boryslav,101,135,150,165
# Karpenko Dmitro,201,155,175,185
# Вимоги:

# відкрийте файл output для запису, використовуючи менеджер контексту with та режим w.
# запис нового вмісту файлу output має бути або за допомогою методу writelines, або використовувати метод write



# ++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++


# from pathlib import Path

# def save_applicant_data ( source, output ) : # Функція  Приймає два параметра , *source - це список словників і *output шлях до файлу в який будемо записувати результат роботи функції

#        with open (output , "w") as fh :      # Відкриваємо наш файл на який вкзує *output з параметром "w" - для запису у файл за допомогою менеджера контексту wiht ... as :
        
#         for student in  source :    # Цикл в якому будемо проходитись по елементах списку *source які є словниками в нашому випадку ,
#                                     # і за допомогою вкладеного циклу  for  value in student.values() : збирати значення словника і записувати їх через кому  в окремий рядок .
#                                     # В кінці замість коми будемо ставити сивмол нового рядка *\n
#                                     # на кожній ітерації циклу в кінці сформований рядок будемо відразу записувати в файл а який вказує *output
#                                     # Після запису останього рядка файл закриється , Дані будуть збереженні в ньому. 
            
#             count = 0               # Лічильник , використаємо що останій символ кому замінити на знак нового рядка *\n ,Оскільки в нас всі дані йдуть в форматі 5 значеь розділених між собою комою. 
#                                     # Інофрмація про кожного студента має починатись з нового рядка. Початкое значення лічильника рівне 0 буде встановлюватись для кожного значення *student . В середені вкладеного циклу змінюватись .
#             info_student =""        # зміній *info_student присвюєм початкове занчення пустоної стрічки буде встановлюватись для кожного значення *student . В середені  вкладеного  циклу змінюватись .
                              
#             for  value in student.values() : # Вкладений цикл в якому будемо проходитись по значеннях з словника *student.vlues()-метод який повертає значення кожного ключа з словника який вказаний перед карпкою.
#                                              # Перші 4 значення записуємо через кому в стрічку *info_student через кому а після останього пятого ставимо знак нового рядка *\n
#                     if count < 4 :           # Умова для перших 4 значень . Перевіряємо по лічильнику.
                        
#                         info_student += f"{value}," # записуємо в *info_student стрічку утворену методом f""-рядка . Де в лапках "" вказуємо змінні дані в фігурних дужках{} а незмінні просто записуємо.
#                                                     # В нашому випалку на першій ітерації циклу  *info_student буде містити Kovalchuk Oleksiy, на другій  Kovalchuk Oleksiy,301, на третій Kovalchuk Oleksiy,301,175, і так далі. 
#                         count += 1                    # збільшуємо наш лічильник на 1 .
                    
#                     else:                           # Коли наш лічильник прийме значення 4 умова if не виконається і спрацює *else: ,Тоді це буде наш 5 елемент значення який в який потрібно заміть коми поставити знак переносту рядка.
                          
#                         info_student += f"{value}\n" # Для 5 елементй значення з  словника *student в кінці добавляємо \n .
            
#             fh.write ( info_student ) # записуємо  наш сформований рядок віразу в файл. На кожній ітераці циклу *for student in  source : . коли цикл завершиться файл закриється і збережеться за домпомгою методуконтексту with ...as :
            
#             #print (inf_student)


# source = [{"name": "Kovalchuk Oleksiy","specialty": 301,"math": 175,"lang": 180,"eng": 155,},{"name": "Ivanchuk Boryslav","specialty": 101,"math": 135,"lang": 150,"eng": 165,},{"name": "Karpenko Dmitro","specialty": 201,"math": 155,"lang": 175,"eng": 185,}]  # Тестовий приклад

# output = Path ( "Output_studen_list_Zavdania_8.txt" )  # Шлях до тестового файлу для запису .

# save_applicant_data ( source, output )  # Виклки функції.


# ======================================= Завдання 9 /Task 9 ========================

# ++++++++++++++++ Робота з байтрядками У ФАЙЛІ   +++++++++++++++++++

# Дані у пам'яті комп'ютера зберігаються у вигляді послідовності байтів. Відповідно, будь-які дані можна подати у вигляді послідовності байтів.
#  Для роботи з "сирими" даними в Python є два типи даних: bytes та bytearray.

# Дуже багато протоколів досі працюють із "сирими" даними або просто потоком байтів, наприклад TCP/IP, послідовний порт, telnet і багато інших.

# Щоб працювати з послідовністю байтів у Python є вбудовані типи даних байт-рядків (bytes) та масиви байтів bytearray.

# BYTES
# За своєю суттю байт-рядки або простіше байти — це звичайні рядки, але для запису одного символу використовується суворо один байт.

# Байт — це одиниця зберігання та обробки цифрової інформації, що містить 8 біт інформації. Один біт — це 0 або 1. За допомогою одного байта 
# можна записати будь-яке число від 0 до 255 включно.

# Для байт-рядків застосовні ті ж обмеження і правила, що і для звичайних рядків:

# байт-рядки — незмінні;
# байт-рядки — послідовні і до їх елементів можна звертатися по індексу:
#   s = b'Hello!'
#   print(s[1])  # b'e'
# байт-рядки підтримують більшість методів рядків, таких як upper, startswith, index, find та інші.
# Створення байт-рядків
# byte_string = b'Hello world!'
# В цьому прикладі у byte_string міститься послідовність символів по одному байту на кожного. 
# Від оголошення звичайного рядка байт-рядок відрізняє наявність символу b перед самим рядком.

# Другий спосіб створення байт рядків — це перетворення у байт-рядок.

# Для перетворення рядка у байт-рядок можна скористатися методом рядків encode:

# byte_str = 'some text'.encode()
# У byte_str буде записана послідовність байтів.

# В один байт поміщається число від 0 до 255 включно, відповідно можна перетворити послідовність чисел від 0 до 255 у байт-рядок
# за допомогою функції bytes:

# numbers = [0, 128, 255]
# byte_numbers = bytes(numbers)
# КОДУВАННЯ РЯДКІВ (ASCII, UTF-8, CP1251)
# Перші комп'ютери для роботи з текстом використали так зване ASCII кодування. У цьому кодуванні для запису одного символу використовується один байт.

# Зручність цього кодування в тому, що будь-які дані на комп'ютері можна спробувати представити у вигляді тексту в цьому кодуванні. 
# ASCII містить 256 символів. Це не дуже багато і деякий час цього було достатньо. Але з часом алфавіту з 256 символів стало мало, 
# виникла необхідність додати все більше символів (кирилиця, діакритичні знаки, коди валют, ієрогліфи та ін.). 
# Щоб задовольнити потребу в додаванні нових символів, придумали використати кодування, де більше за одного байту на символ. 
# Python за замовчуванням використовує UTF-8, в якій один символ може займати від 1 до 4 байт, і всього в алфавіті може бути до 1 112 064 знаків. 
# Це не єдине кодування, на різних платформах можуть бути присутні власні, наприклад CP-1251 (кирилиця на ОС сімейства Windows), UTF-16, UTF-32 
# і інші.

# Щоб дізнатися, якому елементу в UTF-8 відповідає символ, є функція ord (від order).

# Наприклад, символ 'a' кодується числом 97:

# ord('a')  # 97
# Зворотна операція, коли треба дізнатися, що за символ закодований числом, наприклад 128, є функція chr (скорочено від character):

# chr(128)  # 'd'
# Python може працювати з дуже великою кількістю різних кодувань.

# s = "Привет!"

# utf8 = s.encode()
# print(utf8)  # b'\xd0\x9f\xd1\x80\xd0\xb8\xd0\xb2\xd0\xb5\xd1\x82!'

# utf16 = s.encode('utf-16')
# print(utf16)  # b'\xff\xfe\x1f\x04@\x048\x042\x045\x04B\x04!\x00'

# s_from_utf16 = utf16.decode('utf-16')
# print(s_from_utf16 == s)  # True
# Спроба перетворити байт-рядок в неправильному кодуванні приводить або до помилки, або до досить непередбачуваного результату:

# print(b'Hello world!'.decode('utf-16'))  # 效汬潷汲Ⅴ
# ПОРІВНЯННЯ РЯДКІВ
# Порівняння рядків у Python може давати неоднозначний результат у наслідок того, що в UTF-8 кодуванні один і той же символ 
# можна представити декількома кодами, наприклад символ 'ê' можна представити кодом U+00EA, або як послідовність двох кодів U+0065 та U+0302. 
# З цієї причини порівняння одного і того ж символу може повернути False із-за відмінностей в записі.

# Щоб розв'язати цю проблему при роботі з не ASCII символами для порівняння рядків, їх необхідно нормалізувати за допомогою методу casefold, 
# який повертає рядок, де всі символи у нижньому регістрі і без неоднозначностей, коли будь-який символ матиме тільки одну можливу форму запису.


# +++++++++++++++++++++++++++++++++++++++   Умова    +++++++++++++++++++++++++++++++++

# Є два рядки у різних кодуваннях - "utf-8" та "utf-16". Нам необхідно зрозуміти, чи дорівнюються рядки між собою.

# Реалізуйте функцію is_equal_string(utf8_string, utf16_string), яка повертає True, якщо рядки дорівнюють собі, і False — якщо ні.

# ++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++


# def is_equal_string(utf8_string, utf16_string): # функція *is_equal_string(utf8_string, utf16_string), яка повертає True, якщо рядки дорівнюють собі, і False — якщо ні
    
    
#     if utf8_string.decode() == utf16_string.decode('utf-16') : # Порвнюємо два рядки преденні у функцію , Для того спочатку декодуємо рядки в звичайні ряки методом *str.decode() 
#                                                                # де в душках ваказуємо з якого кодування byte-рфдки перекодовуємо в звичайні рядки . Якщо дужки порожні то те саме що *str.decode("utf8")
#                                                                # *str.decode('utf-16') декодувати з 'utf-16'
#                                                                # Врізних системах кодування символів одні і ті самі символи можуть бути записанні по різному. Тому ми спочатку декодовуємо byte-рядки відповідно до системи в якій вони записані а тоді їх порівнюємо.
#         return True                 # Якщо декодаовані рядк одинакові повертаємо *True                      
#     else:                           # інакше
#         return False                # Повертаємо *False





# s = " Україна "  # тестовий рядок для кодування.
# utf8_string = s.casefold().encode() # закодований в utf-8 = b' \xd1\x83\xd0\xba\xd1\x80\xd0\xb0\xd1\x97\xd0\xbd\xd0\xb0 ' . нормалізуємо рядок методом .casefold()-необовязково. і кодуємо методом .encode()
# utf16_string = s.casefold().encode('utf-16') #  акодований в utf-16 = b'\xff\xfe \x00C\x04:\x04@\x040\x04W\x04=\x040\x04 \x00'  нормалізуємо рядок методом .casefold()-необовязково. і кодуємо методом .encode('utf-16')


# print( is_equal_string ( utf8_string, utf16_string ) )  # Виводимо на екран результат роботи фінкції . В нашому випадку *True оскльки один і той самий рядок був закодований двома різними кодами .


# ======================================= Завдання 10 /Task 10 ========================

# ++++++++++++++++ Робота з байтрядками У ФАЙЛІ   +++++++++++++++++++

# Поки що ми розглядали тільки роботу з текстовими файлами в кодуванні UTF-8. Це режим роботи за замовчуванням. 
# Якщо ж потрібно працювати не з текстовими файлами, то можна вказати режим відкриття файлів з b, скорочено від bytes. 
# У такому режимі ви отримаєте файловий дескриптор для роботи з файлом в режимі байт-рядків.

# with open('raw_data.bin', 'wb') as fh:
#     fh.write(b'Hello world!')
# В цьому прикладі ми відкрили файл raw_data.bin у режимі для запису "сирих" даних, на що вказує значення wb. 
# В цьому режимі можна писати у файл тільки байт-рядки або байт-масиви.

# У режимі роботи з "сирими" даними можна відкрити та прочитати вміст будь-якого файлу, в тому числі і архиву.

# +++++++++++++++++++++++++++++++++++++++   Умова    +++++++++++++++++++++++++++++++++

# Дані про користувачів краще зберігати у форматі бінарних файлів. Тому вам необхідно створити функцію, 
# яка буде записувати логін та пароль користувача у файл.

# Реалізуйте функцію save_credentials_users(path, users_info), яка зберігає інформацію про користувачів з паролями в бінарний файл.

# Де:

# path – шлях до файлу.
# users_info - словник типу {'andry':'uyro18890D', 'steve':'oppjM13LL9e'}, де ключ — логін (username) користувача, а значення — його пароль (password).
# Вимоги:

# Кожен рядок файлу повинен мати такий вигляд username:password. Такий формат запису використовують при Базовій аутентифікації.
# Відкрийте файл для запису та збережіть ключ та значення зі словника users_info у вигляді окремого рядка username:password для кожного 
# елемента словника users_info

# ++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

# from pathlib import Path

# def save_credentials_users(path, users_info) : # функціz *save_credentials_users(path, users_info), яка зберігає інформацію про користувачів з паролями в бінарний файл.
#                                                # приймає два занчення *path - шлях до файлу в який будемо записувати дані . *users_info - словник з даними для запису.

#     login_pass = ""   # *login_pass - зміна для запису логіна і пароля в потрібному форматі. Початкова значення пуста стрічка.Тип *str

#     with open ( path ,'wb' ) as fh : # вікриваємо файл на який вказує *path для запису 

#         for key , value in users_info.items() : # цикл в якому будемо проходитись по ключу і значенню його з наого словника і формувати рядок формату username:password
#                                                 # Де кожну поьточну пару  key , value будемо записувати в бінарній формі з новго рядка.
            
#             login_pass = f"{key}:{value}\n"     # Формує рядок для запису . Внашому прикладі вигляд перший рядок буде  такий  andry:uyro18890D\n
#                                                 # Наступний steve:oppjM13LL9e\n
            
            
#             fh.write(bytes(login_pass, 'utf-8')) # записуємо в наш файл перетворений *login_pass в байт рядок з кодуванням 'utf-8' .на кожній ітерації



# path = Path( "Save_user_login_pass_Zavdnia_10.txt" )  # Повертає в *path шлях до вказаного файлу. 

# users_info = {'andry':'uyro18890D', 'steve':'oppjM13LL9e'}  # Тестовий словник.

# save_credentials_users ( path, users_info ) # Виклик функції *save_credentials_users ( path, users_info )



# ======================================= Завдання 11 /Task 11 ========================

# ++++++++++++++++ Робота з байтрядками У ФАЙЛІ. ЧИТАННЯ БІНАРНИХ ФАЙЛІВ У PYTHON +++++++++++++++++++

# +++++++++++++++++++++++++++++++++++++++   Умова    +++++++++++++++++++++++++++++++++

# Реалізуйте функцію get_credentials_users(path), яка повертає список рядків із бінарного файлу, створеного в попередньому завданню, де:

# path – шлях до файлу.
# Формат файлу:

# andry:uyro18890D
# steve:oppjM13LL9e
# Відкрийте файл для читання, використовуючи with та режим rb. Сформуйте список рядків із файлу та поверніть його 
# з функції get_credentials_users у наступному форматі:

# ['andry:uyro18890D', 'steve:oppjM13LL9e']
# Вимоги:

# Використовуйте менеджер контексту для читання з файлу


# ++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++



# from pathlib import Path
# import re

# def get_credentials_users(path): # функція *get_credentials_users(path), яка повертає список рядків із бінарного файлу, створеного в попередньому завданню

#     login_pass = []   # *login_pass - зміна для запису логіна і пароля зчитаних з заданого в *path файлі.. Початкова значення пуста список.Тип *list
#     format_login_pass = []    # *user_info  - зміна в яку будемо записувати 
#     with open ( path ,'rb' ) as fh : # вікриваємо файл на який вказує *path для читання в режимі бінарних рядків .*'rb' 
#             login_pass = fh.readlines() # зчитуємо по рядково всію фноврамію з файлу .І записуємо її в *login_pass
#                                         # Для нашого прикладу буде виглядати [b'andry:uyro18890D\n', b'steve:oppjM13LL9e\n']
#                                         # В цьому списку є зайвими символи *b' і \n/
#             print (login_pass)

#             patern ="(b'|\n)"           # патерн який містить символи які потрібно викикнути з рядка.
#             replace = ''                # порожній символ для заміни потрібних
            
#             for element in login_pass : # Цикл в якому будемо проходитись елементах  по списку *login_pass  . 
#                                         # Декодувати їх .
#                                         # Видаляти/замінювати  не потрібні елементи і готовий елемент добавляти в новий  список 
                  
#                   element = element.decode() # Декодуємо оточний елемент з списку в "utf-8"
#                   element = re.sub (patern , replace , element) # Видаляємо/ замінюємо не потрібні нм сиволи (це b' і \n) пустим символом через метод re.sub() ,
#                   format_login_pass.append(element) # Формуємо новий список з відформатованих до потрібного вигляду елементів.
            
#             return format_login_pass # Повертаємо відформатваний список з функції.
            
            
  

# path = Path( "Save_user_login_pass_Zavdnia_10.txt" )  # Повертає в *path шлях до вказаного файлу. 


# print ( get_credentials_users (path) ) # Виводим на екран результат роботи функції . В нашому випадку ['andry:uyro18890D', 'steve:oppjM13LL9e']



# ======================================= Завдання 12 /Task 12 ========================

# ++++++++++++++++ Робота з base64_bytes   +++++++++++++++++++


# У комп'ютерах всі дані різних типів передаються як одиниці та нулі. Однак деякі канали зв'язку та додатки не завжди можуть зрозуміти всі біти, 
# які вони отримують.

# Щоб обійти це обмеження, ви можете кодувати свої дані в текст, підвищуючи шанси на їхню правильну передачу та обробку. 
# Base64 - популярний формат перетворення двійкових даних на символи ASCII, що широко використовується в більшості мереж та додатків.

# Так, наприклад, зображення в HTML може виглядати так:

# <img src="data:image/png;base64,aVRBOw0AKg1mL9..."/>
# Це зображення у вигляді тексту

# Тепер подивімося, як ми можемо використати в Python Base64 для кодування та декодування даних.

# Python надає base64 модуль, який дозволяє легко кодувати та декодувати інформацію. Спочатку ми конвертуємо рядок у байтовий об'єкт. 
# Після перетворення ми можемо використовувати base64 модуль для його кодування.

# Приклад:

# import base64

# message = "Hello world!"
# message_bytes = message.encode("utf-8")
# base64_bytes = base64.b64encode(message_bytes)
# base64_message = base64_bytes.decode("utf-8")

# print(base64_message)  # SGVsbG8gd29ybGQh
# У наведеному вище прикладі ми імпортували base64 модуль. Змінну message конвертуємо в байтовий об'єкт, використовуючи рядковий метод encode, 
# і зберігаємо його в message_bytes. Потім ми кодуємо message_bytes та зберігаємо результат в base64_bytes, 
# використовуючи base64.b64encode метод. Нарешті, ми отримуємо представлення перетворення Base64 у вигляді рядка, декодуючи змінну base64_bytes. 
# В результаті змінна base64_message зберігатиме наступний рядок SGVsbG8gd29ybGQh

# При Базовій аутентифікації пару username:password частіше всього кодують у Base64 форматі.

# Якщо використовується схема авторизації «Базова», дані користувача формуються так:

# Логін та пароль, розділені двокрапкою aladdin:opensesame.
# Підсумковий рядок, закодований в Base64 YWxhZGRpbjpvcGVuc2VzYW1l.

# +++++++++++++++++++++++++++++++++++++++   Умова    +++++++++++++++++++++++++++++++++

# Функція get_credentials_users із попереднього завдання повертає нам список рядків username:password:

# ['andry:uyro18890D', 'steve:oppjM13LL9e']
# Реалізуйте функцію encode_data_to_base64(data), яка приймає у параметрі data зазначений список, 
# виконує кодування кожної пари username:password у формат Base64 та повертає список із закодованими парами username:password у вигляді:

# ['YW5kcnk6dXlybzE4ODkwRA==', 'c3RldmU6b3Bwak0xM0xMOWU=']

# ++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

# import base64 # Імпорт бібліотеки *base64 для роботи з обєктами ціє бібліотеки. Біблотека працює з кодуваннями і розкодуваннями base64. Опис є напочатку завдання.


# def encode_data_to_base64(data):  # функція *encode_data_to_base64(data), яка приймає у параметрі data зазначений список, 
#                                   # виконує кодування кожної пари username:password у формат Base64 та повертає список із закодованими 
#                                   # парами username:password у вигляді:  ['YW5kcnk6dXlybzE4ODkwRA==', 'c3RldmU6b3Bwak0xM0xMOWU=']
    
#     encode_date = []  # *encode_date список в який будемо записувати наші закодовані дані для кожної пари ключ значення з списку *data.

#     for element in data :  # цикл в якому будемо проходитись по елементах спику *data
#                            # спочатку кодувати їх в "utf-8" далі цей закодований рядок будемо кодувати в base64.b64encode()
#                            # декодуємо його в ("utf-8")
#                            # в кінці Поточний закодований елемент додаємо до списку *encode_date

#         data_bytes = element.encode ( "utf-8" ) # *data_bytes - записуємо поточний елемент в кодуванні ( "utf-8" ) . в нашому прикладі - b'andry:uyro18890D'
#         print ( data_bytes )
#         base64_bytes = base64.b64encode ( data_bytes ) # *base64_bytes - записуємо поточний елемент в кодуванні base64.b64encode() . в нашому прикладі - b'YW5kcnk6dXlybzE4ODkwRA=='
#         print ( base64_bytes )
#         base64_data = base64_bytes.decode ( "utf-8" )  # *base64_data записуємо поточний декодований елемент в кодуванні ( "utf-8" ) . в нашому прикладі - 'YW5kcnk6dXlybzE4ODkwRA=='
#         encode_date.append ( base64_data )    # Додаємо до списку поточний елемент.
    
#     return encode_date  # Повертає список в потрібному форматі значеннь.





# data = ['andry:uyro18890D', 'steve:oppjM13LL9e']  # Тестовий список .


# print (  encode_data_to_base64 (data) )  # Вивід на екран результат роботи фінкції . Для наших тестовх занчень буде вивдоти :  ['YW5kcnk6dXlybzE4ODkwRA==', 'c3RldmU6b3Bwak0xM0xMOWU=']




# ======================================= Завдання 13 /Task 13 ========================

# ++++++++++++++++ Робота з архівами. бібліотека *shutil  +++++++++++++++++++

# Архіви по своїй суті — це ті ж файли, але інформація в них розташована з використанням алгоритмів стискування, 
# які дозволяють записати інформацію в меншому об'ємі.

# Ви можете відкрити будь-який архів, як файл в режимі роботи з байт-строками, реалізувати алгоритм стискування і розпаковування на Python,
# і отримати власний архіватор/деархіватор.

# Ця досить цікава вправа, і ви звичайно можете її виконати, якщо хочете глибше розібратися в алгоритмах стискування.

# Одна з головних причин популярності Python - в наявності великого числа пакетів та модулів зі всіляким функціоналом, 
# які можна використати для своїх потреб. 
# Є простіший спосіб роботи з популярними безкоштовними архівами у Python — це пакет shutil, 
# який представляє собою більш просунутий файловий менеджер і уміє працювати з архівами.

# shutil підтримує архіви zip, tar, gz. Для цього він використовує пакети zipfile та tarfile. Ви можете використовувати їх напряму, якщо хочете.

# Щоб запакувати в архів поточну папку, достатньо викликати функцію make_archive пакету shutil:

# import shutil

# archive_name = shutil.make_archive('backup', 'zip')
# Якщо треба запакувати іншу папку, можна вказати шлях до папки третім аргументом:

# import shutil

# archive_name = shutil.make_archive('backup', 'zip', 'some_folder/inner')
# Обидва виклика створять файл backup.zip в поточній робочій папці, а в archive_name буде рядок з повним шляхом до архіву.

# Звичайно пакет shutil підтримує розпаковування архівів. Для цього є функція unpack_archive, 
# яка розпакує архів у поточну папку або куди вкаже другий аргумент:

# import shutil

# archive_name = shutil.make_archive('backup', 'zip', 'some_folder/inner')
# shutil.unpack_archive(archive_name, 'new_folder_for_data')
# В цьому прикладі спочатку папка 'some_folder/inner' була упакована у backup.zip, а потім backup.zip був розпакован у папку 'new_folder_for_data'.

# Щоб дізнатися, які формати підтримує пакет і які для них використовуються позначення, можна викликати функцію get_archive_formats.

# import shutil

# for shortcut, description in shutil.get_archive_formats():
#     print('{:<10} | {:<10}'.format(shortcut, description))
# У виводі ви отримаєте таблицю зі скороченням формату архіва та його коротким описом виду:

# """
# bztar      | bzip2'ed tar-file
# gztar      | gzip'ed tar-file
# tar        | uncompressed tar file
# xztar      | xz'ed tar-file
# zip        | ZIP file  
# """
# Основна перевага використання shutil — це зручний інтерфейс, який візьме на себе рекурсивний прохід по усіх вкладених файлах і папках 
# та збереже структуру файлів та папок як при архівації, так і при розпаковуванні архіву.


# +++++++++++++++++++++++++++++++++++++++   Умова    +++++++++++++++++++++++++++++++++

# Реалізуйте функцію create_backup(path, file_name, employee_residence)

# Де:

# path — шлях до файлу
# file_name — ім'я файлу
# employee_residence — словник, у якому ключ — ім'я користувача, а значення — країна проживання. 
# Вигляд: {'Michael': 'Canada', 'John':'USA', 'Liza': 'Australia'}
# Функція повинна працювати так:

# Створювати бінарний файл file_name за шляхом path
# Зберігати дані словника employee_residence у файл, де кожен новий рядок — це ключ значення через пробіл як "Michael Canada"
# Архівувати теку по шляху path за допомогою shutil
# Ім'я архіву має бути backup_folder.zip
# Функція має повернути рядок шляху до архіву backup_folder.zip
# Вимоги:

# запишіть вміст словника employee_residence у бінарний файл з ім'ям file_name у теку path за допомогою оператора with.
# використовуйте символ /, щоб розділити шлях для path та file_name
# вигляд рядка файлу — Michael Canada, в кінці кожного рядка додається перенесення рядка '\n'.
# при збереженні кожен рядок файлу кодується методом encode
# при записі рядків використовуємо лише метод write
# архів має бути у форматі zip з ім'ям 'backup_folder', створений за допомогою make_archive.


# ++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++
#Код для автоперевірки 

# import shutil 


# def create_backup(path, file_name, employee_residence):
#     with open(path + '/' + file_name, 'wb') as fh:
#         for k, v in employee_residence.items():
#             print(k, v)
#             fh.write(f'{k} {v}\n'.encode())
#         archive_name = shutil.make_archive("backup_folder", "zip", path)
#         return archive_name
    



# ======================================= Завдання 14 /Task 14 ========================

# ++++++++++++++++ Робота з архівами. бібліотека *shutil  +++++++++++++++++++



# +++++++++++++++++++++++++++++++++++++++   Умова    +++++++++++++++++++++++++++++++++

# Створіть функціонал для розпакування архіву.

# Зробіть import пакету shutil

# Створіть функцію unpack(archive_path, path_to_unpack), яка викликатиме метод пакета shutil unpack_archive та розпаковуватиме 
# архів archive_path у місце path_to_unpack.

# Функція нічого не повертає.


# ++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++
# import shutil



# def unpack(archive_path, path_to_unpack):
#     shutil.unpack_archive(archive_path, path_to_unpack)


